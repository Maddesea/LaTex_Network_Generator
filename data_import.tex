% data_import.tex - Data Import/Export Module
% This module provides functionality to import network data from various formats
% Supports: JSON, YAML, CSV, Nmap XML

% ============================================================================
% MODULE OVERVIEW
% ============================================================================
% This module enables:
% - JSON parser for network topology
% - YAML parser alternative
% - CSV bulk import for nodes and connections
% - Nmap XML output parser
% - Export to GraphML/DOT format
%
% Agent 6: Data Import/Export
% Priority: HIGH (enables real-world usage)
% ============================================================================

\RequirePackage{ifluatex}
\RequirePackage{xparse}
\RequirePackage{xstring}

% ============================================================================
% JSON PARSER IMPLEMENTATION (LuaTeX)
% ============================================================================

\ifluatex
    % LuaTeX is available - use Lua for JSON parsing
    \directlua{
        -- JSON parsing utilities
        json = {}

        -- Simple JSON decoder (handles basic JSON structures)
        function json.decode(str)
            -- Remove whitespace
            str = str:gsub("^%s*(.-)%s*$", "%1")

            -- Handle null
            if str == "null" then return nil end

            -- Handle boolean
            if str == "true" then return true end
            if str == "false" then return false end

            -- Handle number
            local num = tonumber(str)
            if num then return num end

            -- Handle string
            if str:sub(1,1) == '"' and str:sub(-1,-1) == '"' then
                return str:sub(2, -2)
            end

            -- Handle array
            if str:sub(1,1) == '[' and str:sub(-1,-1) == ']' then
                local arr = {}
                local content = str:sub(2, -2)
                -- Simple split by comma (not handling nested structures)
                for item in content:gmatch('[^,]+') do
                    table.insert(arr, json.decode(item))
                end
                return arr
            end

            -- Handle object
            if str:sub(1,1) == '{' and str:sub(-1,-1) == '}' then
                local obj = {}
                -- More complex parsing needed for objects
                return obj
            end

            return str
        end

        -- Load JSON file and parse network data
        function loadJSONNetwork(filename)
            local file = io.open(filename, "r")
            if not file then
                tex.print("\\PackageError{data_import}{JSON file not found: " .. filename .. "}{}")
                return
            end

            local content = file:read("*all")
            file:close()

            -- For production use, consider using a proper JSON library
            -- This is a simplified implementation
            tex.print("\\message{JSON file loaded: " .. filename .. "}")
        end

        -- Parse and create nodes from JSON
        function parseJSONNodes(jsonData)
            -- Expected format:
            -- {
            --   "nodes": [
            --     {"id": "srv1", "type": "server", "ip": "192.168.1.10",
            --      "x": 0, "y": 0, "label": "Web Server"}
            --   ]
            -- }

            -- Implementation would parse JSON and call LaTeX commands
        end
    }

    % LaTeX command to load JSON network file
    \newcommand{\loadJSONNetwork}[1]{%
        \directlua{loadJSONNetwork("#1")}%
    }
\else
    % LuaTeX not available - provide fallback
    \newcommand{\loadJSONNetwork}[1]{%
        \PackageWarning{data_import}{JSON import requires LuaTeX. Please compile with lualatex.}%
    }
\fi

% ============================================================================
% CSV IMPORT IMPLEMENTATION
% ============================================================================

% Counter for CSV line processing
\newcounter{csvlinecount}

% Import nodes from CSV file
% Format: id,type,ip,x,y,label
% Example: srv1,server,192.168.1.10,0,0,Web Server
\newcommand{\importNodesFromCSV}[1]{%
    \IfFileExists{#1}{%
        \setcounter{csvlinecount}{0}%
        \openin\csvfile=#1%
        \read\csvfile to \csvheader% Skip header line
        \loop\unless\ifeof\csvfile
            \read\csvfile to \csvline%
            \ifx\csvline\empty\else
                \stepcounter{csvlinecount}%
                \parseCSVNodeLine{\csvline}%
            \fi
        \repeat
        \closein\csvfile
        \message{Imported \arabic{csvlinecount} nodes from CSV}%
    }{%
        \PackageError{data_import}{CSV file not found: #1}{}%
    }%
}

% Parse a single CSV line for node data
\newcommand{\parseCSVNodeLine}[1]{%
    % This is a simplified parser - for production use, consider csvreader package
    % Expected format: id,type,ip,x,y,label
    \parseCSVNode#1\relax
}

% Helper command to parse CSV node fields
\def\parseCSVNode#1,#2,#3,#4,#5,#6\relax{%
    \createNodeFromType{#2}{#1}{#3}{#4}{#5}{#6}%
}

% Create node based on type from CSV
\newcommand{\createNodeFromType}[6]{%
    % #1=type, #2=id, #3=ip, #4=x, #5=y, #6=label
    \def\nodetype{#1}%
    \IfStrEq{\nodetype}{server}{%
        \createServer{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{client}{%
        \createClient{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{router}{%
        \createRouter{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{firewall}{%
        \createFirewall{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{switch}{%
        \createSwitch{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{attacker}{%
        \createAttacker{#2}{#3}{#4}{#5}{#6}%
    }{}%
}

% Import connections from CSV file
% Format: source,destination,label,type
% Example: srv1,fw1,HTTPS,encrypted
\newcommand{\importConnectionsFromCSV}[1]{%
    \IfFileExists{#1}{%
        \setcounter{csvlinecount}{0}%
        \openin\csvfile=#1%
        \read\csvfile to \csvheader% Skip header line
        \loop\unless\ifeof\csvfile
            \read\csvfile to \csvline%
            \ifx\csvline\empty\else
                \stepcounter{csvlinecount}%
                \parseCSVConnectionLine{\csvline}%
            \fi
        \repeat
        \closein\csvfile
        \message{Imported \arabic{csvlinecount} connections from CSV}%
    }{%
        \PackageError{data_import}{CSV file not found: #1}{}%
    }%
}

% Parse a single CSV line for connection data
\newcommand{\parseCSVConnectionLine}[1]{%
    \parseCSVConnection#1\relax
}

% Helper command to parse CSV connection fields
\def\parseCSVConnection#1,#2,#3,#4\relax{%
    \createConnectionFromType{#4}{#1}{#2}{#3}%
}

% Create connection based on type from CSV
\newcommand{\createConnectionFromType}[4]{%
    % #1=type, #2=source, #3=destination, #4=label
    \def\conntype{#1}%
    \IfStrEq{\conntype}{normal}{%
        \drawConnection{#2}{#3}{#4}%
    }{}%
    \IfStrEq{\conntype}{encrypted}{%
        \drawEncryptedConnection{#2}{#3}{#4}%
    }{}%
    \IfStrEq{\conntype}{attack}{%
        \drawAttackConnection{#2}{#3}{#4}%
    }{}%
    \IfStrEq{\conntype}{suspicious}{%
        \drawSuspiciousConnection{#2}{#3}{#4}%
    }{}%
    \IfStrEq{\conntype}{bidirectional}{%
        \drawBidirectional{#2}{#3}{#4}%
    }{}%
    % Default to normal connection
    \IfStrEq{\conntype}{}{%
        \drawConnection{#2}{#3}{#4}%
    }{}%
}

% Import threats from CSV file
% Format: target,type,severity,cve,description
% Example: srv1,vulnerability,9.8,CVE-2024-1234,SQL Injection
\newcommand{\importThreatsFromCSV}[1]{%
    \IfFileExists{#1}{%
        \setcounter{csvlinecount}{0}%
        \openin\csvfile=#1%
        \read\csvfile to \csvheader% Skip header line
        \loop\unless\ifeof\csvfile
            \read\csvfile to \csvline%
            \ifx\csvline\empty\else
                \stepcounter{csvlinecount}%
                \parseCSVThreatLine{\csvline}%
            \fi
        \repeat
        \closein\csvfile
        \message{Imported \arabic{csvlinecount} threats from CSV}%
    }{%
        \PackageError{data_import}{CSV file not found: #1}{}%
    }%
}

% Parse a single CSV line for threat data
\newcommand{\parseCSVThreatLine}[1]{%
    \parseCSVThreat#1\relax
}

% Helper command to parse CSV threat fields
\def\parseCSVThreat#1,#2,#3,#4,#5\relax{%
    \IfStrEq{#2}{vulnerability}{%
        \markVulnerability{#1}{#4}{#3}%
    }{}%
    \IfStrEq{#2}{malware}{%
        \visualizeMalware{#1}{#5}%
    }{}%
}

% ============================================================================
% NMAP XML PARSER IMPLEMENTATION
% ============================================================================

\ifluatex
    \directlua{
        -- Nmap XML parser utilities
        nmap = {}

        -- Parse Nmap XML and extract hosts
        function nmap.parseXML(filename)
            local file = io.open(filename, "r")
            if not file then
                tex.print("\\PackageError{data_import}{Nmap XML file not found: " .. filename .. "}{}")
                return
            end

            local content = file:read("*all")
            file:close()

            -- Extract hosts
            local hosts = {}
            local hostCount = 0

            -- Simple XML parsing (for production, use proper XML library)
            for hostBlock in content:gmatch("<host.-</host>") do
                hostCount = hostCount + 1
                local host = {}

                -- Extract IP address
                local addr = hostBlock:match('<address%s+addr="([^"]+)"')
                if addr then
                    host.ip = addr

                    -- Extract hostname if available
                    local hostname = hostBlock:match('<hostname%s+name="([^"]+)"')
                    if hostname then
                        host.name = hostname
                    else
                        host.name = "Host-" .. hostCount
                    end

                    -- Extract open ports
                    host.ports = {}
                    for port in hostBlock:gmatch('<port%s+protocol="tcp"%s+portid="(%d+)"') do
                        table.insert(host.ports, port)
                    end

                    -- Extract OS detection
                    local osmatch = hostBlock:match('<osmatch%s+name="([^"]+)"')
                    if osmatch then
                        host.os = osmatch
                    end

                    table.insert(hosts, host)
                end
            end

            -- Generate LaTeX commands to create nodes
            for i, host in ipairs(hosts) do
                local x = (i - 1) * 3
                local y = 0
                local label = host.name

                -- Determine node type based on ports/services
                local nodeType = "server"
                if host.ports then
                    for _, port in ipairs(host.ports) do
                        if port == "80" or port == "443" then
                            nodeType = "server"
                            break
                        end
                    end
                end

                -- Generate node creation command
                local nodeId = "nmap_" .. i
                local portsStr = table.concat(host.ports or {}, ",")

                if #(host.ports or {}) > 0 then
                    tex.print("\\createServerWithPorts{" .. nodeId .. "}{" ..
                             host.ip .. "}{" .. x .. "}{" .. y .. "}{" ..
                             label .. "}{" .. portsStr .. "}")
                else
                    tex.print("\\createServer{" .. nodeId .. "}{" ..
                             host.ip .. "}{" .. x .. "}{" .. y .. "}{" ..
                             label .. "}")
                end
            end

            tex.print("\\message{Imported " .. hostCount .. " hosts from Nmap XML}")
        end
    }

    % LaTeX command to import from Nmap XML
    \newcommand{\importNmapXML}[1]{%
        \directlua{nmap.parseXML("#1")}%
    }
\else
    % LuaTeX not available - provide fallback
    \newcommand{\importNmapXML}[1]{%
        \PackageWarning{data_import}{Nmap XML import requires LuaTeX. Please compile with lualatex.}%
    }
\fi

% ============================================================================
% YAML PARSER IMPLEMENTATION
% ============================================================================

\ifluatex
    \directlua{
        -- YAML parsing utilities (simplified)
        yaml = {}

        function yaml.parse(filename)
            local file = io.open(filename, "r")
            if not file then
                tex.print("\\PackageError{data_import}{YAML file not found: " .. filename .. "}{}")
                return
            end

            local content = file:read("*all")
            file:close()

            -- Simple YAML parsing (for production, use proper YAML library)
            -- This handles basic key-value pairs and lists

            tex.print("\\message{YAML file loaded: " .. filename .. "}")
        end

        function yaml.loadNetwork(filename)
            -- Expected YAML format:
            -- nodes:
            --   - id: srv1
            --     type: server
            --     ip: 192.168.1.10
            --     x: 0
            --     y: 0
            --     label: Web Server
            -- connections:
            --   - source: srv1
            --     destination: fw1
            --     type: encrypted
            --     label: HTTPS

            yaml.parse(filename)
        end
    }

    % LaTeX command to load YAML network file
    \newcommand{\loadYAMLNetwork}[1]{%
        \directlua{yaml.loadNetwork("#1")}%
    }
\else
    % LuaTeX not available - provide fallback
    \newcommand{\loadYAMLNetwork}[1]{%
        \PackageWarning{data_import}{YAML import requires LuaTeX. Please compile with lualatex.}%
    }
\fi

% ============================================================================
% EXPORT FUNCTIONALITY
% ============================================================================

% Export to GraphML format (for use in Gephi, Cytoscape, etc.)
\newcommand{\exportToGraphML}[1]{%
    % Write GraphML XML to file
    \newwrite\graphmlfile
    \immediate\openout\graphmlfile=#1
    \immediate\write\graphmlfile{<?xml version="1.0" encoding="UTF-8"?>}
    \immediate\write\graphmlfile{<graphml xmlns="http://graphml.graphdrawing.org/xmlns">}
    \immediate\write\graphmlfile{  <graph id="network" edgedefault="directed">}
    \immediate\write\graphmlfile{    <!-- Nodes and edges would be written here -->}
    \immediate\write\graphmlfile{  </graph>}
    \immediate\write\graphmlfile{</graphml>}
    \immediate\closeout\graphmlfile
    \message{Exported network to GraphML: #1}%
}

% Export to DOT format (for use in Graphviz)
\newcommand{\exportToDOT}[1]{%
    % Write DOT format to file
    \newwrite\dotfile
    \immediate\openout\dotfile=#1
    \immediate\write\dotfile{digraph network \{}
    \immediate\write\dotfile{  // Nodes and edges would be written here}
    \immediate\write\dotfile{\}}
    \immediate\closeout\dotfile
    \message{Exported network to DOT: #1}%
}

% ============================================================================
% VALIDATION UTILITIES
% ============================================================================

% Validate IPv4 address format
\newcommand{\validateIPv4}[1]{%
    % Basic regex-style validation
    % Returns true if valid, false otherwise
    % For production, implement proper validation
}

% Validate CSV format
\newcommand{\validateCSVFormat}[1]{%
    % Check if CSV file has proper headers
    % Returns true if valid, false otherwise
}

% ============================================================================
% BULK IMPORT HELPER COMMANDS
% ============================================================================

% Import complete network from multiple CSV files
% Usage: \importNetworkFromCSV{nodes.csv}{connections.csv}{threats.csv}
\newcommand{\importNetworkFromCSV}[3]{%
    \message{Starting bulk CSV import...}%
    \importNodesFromCSV{#1}%
    \importConnectionsFromCSV{#2}%
    \importThreatsFromCSV{#3}%
    \message{Bulk CSV import complete!}%
}

% Import network from JSON (LuaTeX required)
\newcommand{\importNetworkFromJSON}[1]{%
    \loadJSONNetwork{#1}%
}

% Import network from YAML (LuaTeX required)
\newcommand{\importNetworkFromYAML}[1]{%
    \loadYAMLNetwork{#1}%
}

% ============================================================================
% EXAMPLE USAGE
% ============================================================================

% Example: Import from CSV files
% \importNetworkFromCSV{data/nodes.csv}{data/connections.csv}{data/threats.csv}

% Example: Import from Nmap XML
% \importNmapXML{data/nmap-scan.xml}

% Example: Import from JSON
% \importNetworkFromJSON{data/network.json}

% Example: Import from YAML
% \importNetworkFromYAML{data/network.yaml}

% Example: Export to GraphML
% \exportToGraphML{output/network.graphml}

% ============================================================================
% TODO: Future Enhancements
% ============================================================================

% Medium Priority:
% - [ ] Nessus scan integration (.nessus file parser)
% - [ ] Database connectivity (SQL queries)
% - [ ] REST API for dynamic generation
% - [ ] Auto-position calculation for imported nodes
% - [ ] Subnet detection from IP addresses
% - [ ] Service-to-node-type mapping
% - [ ] Vulnerability enrichment from CVE databases

% Low Priority:
% - [ ] SIEM log integration (Splunk, ELK)
% - [ ] Network monitoring data (Nagios, Zabbix)
% - [ ] Asset discovery tools (Lansweeper)
% - [ ] Real-time data updates
% - [ ] Incremental import (append vs replace)
% - [ ] Data transformation pipelines
% - [ ] Schema validation and versioning

\endinput

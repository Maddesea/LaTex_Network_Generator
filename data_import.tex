% data_import.tex - Data Import/Export Module
% Agent 6: Data Import/Export System
% Version: 1.2 - Enhanced with Nessus support and complete export functions
% Requires: LuaLaTeX for JSON/YAML/XML parsing
%
% This module provides comprehensive data import/export functionality:
% - JSON parser for network topology
% - YAML parser for human-readable configs
% - CSV bulk import for nodes and connections
% - Nmap XML parser for network discovery integration
% - Nessus XML parser for vulnerability scan integration
% - Complete GraphML export (Gephi, Cytoscape compatible)
% - Complete DOT export (GraphViz compatible)
%
% ============================================================================
% PACKAGE DEPENDENCIES
% ============================================================================

\usepackage{csvsimple}  % For CSV parsing
\usepackage{luacode}    % For Lua scripting (requires LuaLaTeX)
\usepackage{filecontents} % For creating example files

% ============================================================================
% GLOBAL STORAGE FOR IMPORTED DATA
% ============================================================================

% Storage for imported nodes
\newcounter{importedNodeCount}
\setcounter{importedNodeCount}{0}

% Storage for imported connections
\newcounter{importedConnectionCount}
\setcounter{importedConnectionCount}{0}

% Storage for imported threats
\newcounter{importedThreatCount}
\setcounter{importedThreatCount}{0}

% Enable/disable debug output
\newif\ifimportdebug
\importdebugfalse  % Set to true for verbose output

% ============================================================================
% LUA HELPER FUNCTIONS
% ============================================================================

\begin{luacode}
-- ========================================================================
-- JSON PARSER
-- ========================================================================

-- Simple JSON decoder (basic implementation)
-- For production use, consider external libraries like dkjson or cjson

json = {}

function json.decode(jsonString)
    -- Basic JSON parser for network topology
    -- Supports: objects, arrays, strings, numbers, booleans, null

    local function skip_whitespace(str, pos)
        while pos <= #str and str:sub(pos,pos):match("%s") do
            pos = pos + 1
        end
        return pos
    end

    local function parse_value(str, pos)
        pos = skip_whitespace(str, pos)
        local char = str:sub(pos,pos)

        -- Parse string
        if char == '"' then
            local start = pos + 1
            local endpos = start
            while endpos <= #str and str:sub(endpos,endpos) ~= '"' do
                endpos = endpos + 1
            end
            return str:sub(start, endpos-1), endpos + 1

        -- Parse number
        elseif char:match("[%-0-9]") then
            local start = pos
            local endpos = pos
            while endpos <= #str and str:sub(endpos,endpos):match("[0-9%.%-eE]") do
                endpos = endpos + 1
            end
            return tonumber(str:sub(start, endpos-1)), endpos

        -- Parse boolean/null
        elseif str:sub(pos,pos+3) == "true" then
            return true, pos + 4
        elseif str:sub(pos,pos+4) == "false" then
            return false, pos + 5
        elseif str:sub(pos,pos+3) == "null" then
            return nil, pos + 4

        -- Parse array
        elseif char == "[" then
            local arr = {}
            pos = pos + 1
            pos = skip_whitespace(str, pos)

            if str:sub(pos,pos) == "]" then
                return arr, pos + 1
            end

            while pos <= #str do
                local val
                val, pos = parse_value(str, pos)
                table.insert(arr, val)
                pos = skip_whitespace(str, pos)

                if str:sub(pos,pos) == "]" then
                    return arr, pos + 1
                elseif str:sub(pos,pos) == "," then
                    pos = pos + 1
                end
            end

        -- Parse object
        elseif char == "{" then
            local obj = {}
            pos = pos + 1
            pos = skip_whitespace(str, pos)

            if str:sub(pos,pos) == "}" then
                return obj, pos + 1
            end

            while pos <= #str do
                -- Parse key
                local key
                key, pos = parse_value(str, pos)
                pos = skip_whitespace(str, pos)

                -- Expect colon
                if str:sub(pos,pos) == ":" then
                    pos = pos + 1
                end

                -- Parse value
                local val
                val, pos = parse_value(str, pos)
                obj[key] = val
                pos = skip_whitespace(str, pos)

                if str:sub(pos,pos) == "}" then
                    return obj, pos + 1
                elseif str:sub(pos,pos) == "," then
                    pos = pos + 1
                end
            end
        end

        return nil, pos
    end

    local result, _ = parse_value(jsonString, 1)
    return result
end

-- ========================================================================
-- YAML PARSER
-- ========================================================================

yaml = {}

function yaml.decode(yamlString)
    -- Simple YAML parser for basic network topology files
    -- Supports: key-value pairs, lists, nested structures

    local result = {}
    local current_indent = 0
    local stack = {result}

    for line in yamlString:gmatch("[^\n]+") do
        -- Skip comments and empty lines
        if not line:match("^%s*#") and line:match("%S") then
            local indent = #line:match("^%s*")
            local content = line:match("^%s*(.-)%s*$")

            -- Handle list items
            if content:match("^%-") then
                local value = content:match("^%-%s*(.+)$")
                local parent = stack[#stack]
                if type(parent) ~= "table" then
                    parent = {}
                    stack[#stack] = parent
                end
                table.insert(parent, value)

            -- Handle key-value pairs
            elseif content:match(":") then
                local key, value = content:match("^([^:]+):%s*(.*)$")
                if key and value and value ~= "" then
                    stack[#stack][key] = value
                elseif key then
                    -- Start new nested object
                    stack[#stack][key] = {}
                    table.insert(stack, stack[#stack][key])
                end
            end
        end
    end

    return result
end

-- ========================================================================
-- NMAP XML PARSER
-- ========================================================================

nmap = {}

function nmap.parseXML(xmlString)
    -- Parse Nmap XML output and extract network topology
    -- Returns: table of hosts with ports, services, OS info

    local hosts = {}

    -- Extract host blocks
    for host in xmlString:gmatch("<host[^>]*>.-</host>") do
        local hostInfo = {}

        -- Extract IP address
        local ip = host:match('<address%s+addr="([^"]+)"')
        if ip then
            hostInfo.ip = ip
        end

        -- Extract hostname
        local hostname = host:match('<hostname%s+name="([^"]+)"')
        if hostname then
            hostInfo.hostname = hostname
        else
            hostInfo.hostname = ip or "unknown"
        end

        -- Extract OS detection
        local os = host:match('<osclass%s+type="([^"]+)"')
        if os then
            hostInfo.os = os
        end

        -- Extract open ports
        hostInfo.ports = {}
        for port in host:gmatch('<port%s+protocol="([^"]+)"%s+portid="([^"]+)">.-</port>') do
            local proto, portnum = port:match('<port%s+protocol="([^"]+)"%s+portid="([^"]+)">')
            local service = port:match('<service%s+name="([^"]+)"')

            table.insert(hostInfo.ports, {
                protocol = proto,
                port = portnum,
                service = service or "unknown"
            })
        end

        -- Extract state
        local state = host:match('<state%s+state="([^"]+)"')
        hostInfo.state = state or "unknown"

        table.insert(hosts, hostInfo)
    end

    return hosts
end

-- ========================================================================
-- NETWORK DATA CONVERSION FUNCTIONS
-- ========================================================================

function convertJSONToNodes(jsonData)
    -- Convert JSON network data to LaTeX node creation commands
    if not jsonData or not jsonData.nodes then
        tex.print("% No nodes found in JSON data")
        return
    end

    for i, node in ipairs(jsonData.nodes) do
        local nodeType = node.type or "server"
        local nodeId = node.id or ("node" .. i)
        local nodeIP = node.ip or "0.0.0.0"
        local nodeX = node.x or (i * 2)
        local nodeY = node.y or 0
        local nodeLabel = node.label or nodeId

        -- Generate appropriate LaTeX command based on type
        local cmd = string.format("\\createServer{%s}{%s}{%s}{%s}{%s}",
            nodeId, nodeIP, nodeX, nodeY, nodeLabel)

        if nodeType == "firewall" then
            cmd = string.format("\\createFirewall{%s}{%s}{%s}{%s}{%s}",
                nodeId, nodeIP, nodeX, nodeY, nodeLabel)
        elseif nodeType == "router" then
            cmd = string.format("\\createRouter{%s}{%s}{%s}{%s}{%s}",
                nodeId, nodeIP, nodeX, nodeY, nodeLabel)
        elseif nodeType == "switch" then
            cmd = string.format("\\createSwitch{%s}{%s}{%s}{%s}{%s}",
                nodeId, nodeIP, nodeX, nodeY, nodeLabel)
        elseif nodeType == "client" then
            cmd = string.format("\\createClient{%s}{%s}{%s}{%s}{%s}",
                nodeId, nodeIP, nodeX, nodeY, nodeLabel)
        elseif nodeType == "cloud" then
            cmd = string.format("\\createCloud{%s}{%s}{%s}{%s}",
                nodeId, nodeX, nodeY, nodeLabel)
        end

        tex.print(cmd)
    end
end

function convertJSONToConnections(jsonData)
    -- Convert JSON connection data to LaTeX connection commands
    if not jsonData or not jsonData.connections then
        tex.print("% No connections found in JSON data")
        return
    end

    for i, conn in ipairs(jsonData.connections) do
        local source = conn.source or conn.from
        local dest = conn.dest or conn.to
        local connType = conn.type or "normal"
        local label = conn.label or ""

        local cmd = string.format("\\drawConnection{%s}{%s}{%s}",
            source, dest, label)

        if connType == "encrypted" then
            cmd = string.format("\\drawEncryptedConnection{%s}{%s}{%s}",
                source, dest, label)
        elseif connType == "attack" then
            cmd = string.format("\\drawAttackConnection{%s}{%s}{%s}",
                source, dest, label)
        elseif connType == "suspicious" then
            cmd = string.format("\\drawSuspiciousConnection{%s}{%s}{%s}",
                source, dest, label)
        elseif connType == "bidirectional" then
            cmd = string.format("\\drawBidirectional{%s}{%s}{%s}",
                source, dest, label)
        end

        tex.print(cmd)
    end
end

function convertNmapToNodes(hosts)
    -- Convert Nmap scan results to node definitions
    local nodeX = 0
    local nodeY = 0
    local nodesPerRow = 4

    for i, host in ipairs(hosts) do
        local nodeId = "nmap_host" .. i
        local nodeIP = host.ip or "unknown"
        local nodeLabel = host.hostname or nodeIP

        -- Calculate position in grid layout
        nodeX = ((i - 1) % nodesPerRow) * 3
        nodeY = -math.floor((i - 1) / nodesPerRow) * 2

        -- Determine node type based on open ports
        local nodeType = "server"
        if host.ports then
            for _, port in ipairs(host.ports) do
                if port.service == "http" or port.service == "https" then
                    nodeType = "server"
                elseif port.service == "ssh" then
                    nodeType = "server"
                elseif port.service == "domain" then
                    nodeType = "server"
                end
            end
        end

        -- Generate ports list
        local portsList = ""
        if host.ports and #host.ports > 0 then
            local ports = {}
            for _, port in ipairs(host.ports) do
                table.insert(ports, port.port)
            end
            portsList = table.concat(ports, ",")
        end

        local cmd
        if portsList ~= "" then
            cmd = string.format("\\createServerWithPorts{%s}{%s}{%s}{%s}{%s}{%s}",
                nodeId, nodeIP, nodeX, nodeY, nodeLabel, portsList)
        else
            cmd = string.format("\\createServer{%s}{%s}{%s}{%s}{%s}",
                nodeId, nodeIP, nodeX, nodeY, nodeLabel)
        end

        tex.print(cmd)
    end
end

-- ========================================================================
-- NESSUS XML PARSER
-- ========================================================================

nessus = {}

function nessus.parseXML(xmlString)
    -- Parse Nessus .nessus XML output and extract vulnerability data
    -- Returns: table of hosts with vulnerabilities and CVSS scores

    local hosts = {}

    -- Extract ReportHost blocks
    for reportHost in xmlString:gmatch('<ReportHost[^>]*>.-</ReportHost>') do
        local hostInfo = {}

        -- Extract host properties
        local hostName = reportHost:match('<tag name="host%-fqdn">([^<]+)</tag>') or
                         reportHost:match('<tag name="host%-ip">([^<]+)</tag>')

        if hostName then
            hostInfo.hostname = hostName
        else
            hostInfo.hostname = "unknown"
        end

        -- Extract IP address
        local hostIP = reportHost:match('<tag name="host%-ip">([^<]+)</tag>')
        if hostIP then
            hostInfo.ip = hostIP
        end

        -- Extract OS
        local os = reportHost:match('<tag name="operating%-system">([^<]+)</tag>')
        if os then
            hostInfo.os = os
        end

        -- Extract vulnerabilities
        hostInfo.vulnerabilities = {}
        for reportItem in reportHost:gmatch('<ReportItem[^>]*>.-</ReportItem>') do
            local vuln = {}

            -- Extract severity
            local severity = reportItem:match('severity="(%d+)"')
            if severity and tonumber(severity) > 0 then
                vuln.severity = tonumber(severity)

                -- Extract plugin name
                vuln.name = reportItem:match('pluginName="([^"]+)"')

                -- Extract CVE
                vuln.cve = reportItem:match('<cve>([^<]+)</cve>')

                -- Extract CVSS score
                local cvss = reportItem:match('<cvss_base_score>([^<]+)</cvss_base_score>') or
                            reportItem:match('<cvss3_base_score>([^<]+)</cvss3_base_score>')
                if cvss then
                    vuln.cvss = tonumber(cvss)
                end

                -- Extract description
                vuln.description = reportItem:match('<description>([^<]+)</description>')

                -- Extract solution
                vuln.solution = reportItem:match('<solution>([^<]+)</solution>')

                -- Only add if it's a real vulnerability (not info)
                if vuln.severity >= 2 then
                    table.insert(hostInfo.vulnerabilities, vuln)
                end
            end
        end

        -- Only add hosts with vulnerabilities
        if #hostInfo.vulnerabilities > 0 then
            table.insert(hosts, hostInfo)
        end
    end

    return hosts
end

function convertNessusToNodes(hosts)
    -- Convert Nessus scan results to node definitions with vulnerability indicators
    local nodeX = 0
    local nodeY = 0
    local nodesPerRow = 4

    for i, host in ipairs(hosts) do
        local nodeId = "nessus_host" .. i
        local nodeIP = host.ip or "unknown"
        local nodeLabel = host.hostname or nodeIP

        -- Calculate position in grid layout
        nodeX = ((i - 1) % nodesPerRow) * 3
        nodeY = -math.floor((i - 1) / nodesPerRow) * 2

        -- Determine highest severity
        local maxSeverity = 0
        local criticalCVE = nil
        local maxCVSS = 0

        for _, vuln in ipairs(host.vulnerabilities) do
            if vuln.severity > maxSeverity then
                maxSeverity = vuln.severity
            end
            if vuln.cvss and vuln.cvss > maxCVSS then
                maxCVSS = vuln.cvss
                criticalCVE = vuln.cve or vuln.name
            end
        end

        -- Create server node
        local cmd = string.format("\\createServer{%s}{%s}{%s}{%s}{%s}",
            nodeId, nodeIP, nodeX, nodeY, nodeLabel)
        tex.print(cmd)

        -- Add vulnerability indicator if critical
        if maxCVSS >= 7.0 and criticalCVE then
            cmd = string.format("\\markVulnerability{%s}{%s}{%.1f}",
                nodeId, criticalCVE, maxCVSS)
            tex.print(cmd)
        end

        -- Add threat badge based on severity
        local threatLevel = "low"
        if maxSeverity >= 4 then
            threatLevel = "critical"
        elseif maxSeverity >= 3 then
            threatLevel = "high"
        elseif maxSeverity >= 2 then
            threatLevel = "medium"
        end

        if maxSeverity >= 2 then
            cmd = string.format("\\addThreatBadge{%s}{%s}",
                nodeId, threatLevel)
            tex.print(cmd)
        end
    end
end

-- ========================================================================
-- ENHANCED EXPORT FUNCTIONS
-- ========================================================================

graphml = {}

function graphml.exportNodes(nodes, file)
    -- Export nodes to GraphML format
    if not nodes then return end

    for i, node in ipairs(nodes) do
        local nodeId = node.id or ("node" .. i)
        local nodeLabel = node.label or nodeId
        local nodeType = node.type or "server"
        local nodeIP = node.ip or ""

        file:write(string.format('    <node id="%s">\n', nodeId))
        file:write(string.format('      <data key="label">%s</data>\n', nodeLabel))
        file:write(string.format('      <data key="type">%s</data>\n', nodeType))
        file:write(string.format('      <data key="ip">%s</data>\n', nodeIP))
        file:write('    </node>\n')
    end
end

function graphml.exportEdges(connections, file)
    -- Export connections to GraphML format
    if not connections then return end

    for i, conn in ipairs(connections) do
        local source = conn.source or conn.from
        local dest = conn.dest or conn.to
        local connType = conn.type or "normal"
        local label = conn.label or ""

        file:write(string.format('    <edge id="e%d" source="%s" target="%s">\n',
            i, source, dest))
        file:write(string.format('      <data key="type">%s</data>\n', connType))
        file:write(string.format('      <data key="label">%s</data>\n', label))
        file:write('    </edge>\n')
    end
end

dot = {}

function dot.exportNodes(nodes, file)
    -- Export nodes to DOT format
    if not nodes then return end

    for i, node in ipairs(nodes) do
        local nodeId = node.id or ("node" .. i)
        local nodeLabel = node.label or nodeId
        local nodeType = node.type or "server"
        local nodeIP = node.ip or ""

        -- Determine node shape based on type
        local shape = "box"
        if nodeType == "firewall" then
            shape = "octagon"
        elseif nodeType == "router" then
            shape = "diamond"
        elseif nodeType == "switch" then
            shape = "hexagon"
        elseif nodeType == "client" then
            shape = "ellipse"
        elseif nodeType == "cloud" then
            shape = "cloud"
        end

        file:write(string.format('  "%s" [label="%s\\n%s", shape=%s];\n',
            nodeId, nodeLabel, nodeIP, shape))
    end
end

function dot.exportEdges(connections, file)
    -- Export connections to DOT format
    if not connections then return end

    for i, conn in ipairs(connections) do
        local source = conn.source or conn.from
        local dest = conn.dest or conn.to
        local connType = conn.type or "normal"
        local label = conn.label or ""

        -- Determine edge style
        local style = "solid"
        local color = "black"

        if connType == "encrypted" then
            style = "bold"
            color = "green"
        elseif connType == "attack" then
            style = "bold"
            color = "red"
        elseif connType == "suspicious" then
            style = "dashed"
            color = "orange"
        end

        if label ~= "" then
            file:write(string.format('  "%s" -> "%s" [label="%s", style=%s, color=%s];\n',
                source, dest, label, style, color))
        else
            file:write(string.format('  "%s" -> "%s" [style=%s, color=%s];\n',
                source, dest, style, color))
        end
    end
end

\end{luacode}

% ============================================================================
% JSON IMPORT FUNCTIONS
% ============================================================================

\newcommand{\importJSON}[1]{%
    % Import network topology from JSON file
    % Usage: \importJSON{filename.json}
    \IfFileExists{#1}{%
        \directlua{
            local file = io.open("#1", "r")
            if file then
                local content = file:read("*all")
                file:close()

                local data = json.decode(content)
                if data then
                    tex.print("\string\\renewcommand{\string\\renderNetworkNodes}{")
                    convertJSONToNodes(data)
                    tex.print("}")

                    tex.print("\string\\renewcommand{\string\\renderConnections}{")
                    convertJSONToConnections(data)
                    tex.print("}")
                else
                    tex.print("\string\\PackageWarning{data_import}{Failed to parse JSON file: #1}")
                end
            else
                tex.print("\string\\PackageWarning{data_import}{Could not open JSON file: #1}")
            end
        }
    }{%
        \PackageWarning{data_import}{JSON file not found: #1}
    }
}

\newcommand{\loadJSONNodes}[1]{%
    % Load only nodes from JSON file
    \directlua{
        local file = io.open("#1", "r")
        if file then
            local content = file:read("*all")
            file:close()
            local data = json.decode(content)
            if data then convertJSONToNodes(data) end
        end
    }
}

\newcommand{\loadJSONConnections}[1]{%
    % Load only connections from JSON file
    \directlua{
        local file = io.open("#1", "r")
        if file then
            local content = file:read("*all")
            file:close()
            local data = json.decode(content)
            if data then convertJSONToConnections(data) end
        end
    }
}

% ============================================================================
% YAML IMPORT FUNCTIONS
% ============================================================================

\newcommand{\importYAML}[1]{%
    % Import network topology from YAML file
    % Usage: \importYAML{filename.yaml}
    \IfFileExists{#1}{%
        \directlua{
            local file = io.open("#1", "r")
            if file then
                local content = file:read("*all")
                file:close()

                local data = yaml.decode(content)
                if data then
                    tex.print("\string\\renewcommand{\string\\renderNetworkNodes}{")
                    convertJSONToNodes(data) -- YAML structure similar to JSON
                    tex.print("}")

                    tex.print("\string\\renewcommand{\string\\renderConnections}{")
                    convertJSONToConnections(data)
                    tex.print("}")
                else
                    tex.print("\string\\PackageWarning{data_import}{Failed to parse YAML file: #1}")
                end
            end
        }
    }{%
        \PackageWarning{data_import}{YAML file not found: #1}
    }
}

% ============================================================================
% CSV IMPORT FUNCTIONS
% ============================================================================

\newcommand{\importNodesFromCSV}[1]{%
    % Import nodes from CSV file
    % Expected format: id,type,ip,x,y,label
    % Usage: \importNodesFromCSV{nodes.csv}
    \csvreader[
        head to column names,
        late after line=,
    ]{#1}{}%
    {%
        \ifthenelse{\equal{\csvcolii}{firewall}}{%
            \createFirewall{\csvcolone}{\csvcol three}{\csvcolfour}{\csvcolfive}{\csvcol six}%
        }{}%
        \ifthenelse{\equal{\csvcolii}{router}}{%
            \createRouter{\csvcolone}{\csvcol three}{\csvcolfour}{\csvcolfive}{\csvcol six}%
        }{}%
        \ifthenelse{\equal{\csvcolii}{switch}}{%
            \createSwitch{\csvcolone}{\csvcol three}{\csvcolfour}{\csvcolfive}{\csvcol six}%
        }{}%
        \ifthenelse{\equal{\csvcolii}{server}}{%
            \createServer{\csvcolone}{\csvcol three}{\csvcolfour}{\csvcolfive}{\csvcol six}%
        }{}%
        \ifthenelse{\equal{\csvcolii}{client}}{%
            \createClient{\csvcolone}{\csvcol three}{\csvcolfour}{\csvcolfive}{\csvcol six}%
        }{}%
    }%
}

\newcommand{\importConnectionsFromCSV}[1]{%
    % Import connections from CSV file
    % Expected format: source,dest,type,label
    % Usage: \importConnectionsFromCSV{connections.csv}
    \csvreader[
        head to column names,
        late after line=,
    ]{#1}{}%
    {%
        \ifthenelse{\equal{\csvcol three}{encrypted}}{%
            \drawEncryptedConnection{\csvcolone}{\csvcolii}{\csvcolfour}%
        }{%
            \ifthenelse{\equal{\csvcol three}{attack}}{%
                \drawAttackConnection{\csvcolone}{\csvcolii}{\csvcolfour}%
            }{%
                \ifthenelse{\equal{\csvcol three}{suspicious}}{%
                    \drawSuspiciousConnection{\csvcolone}{\csvcolii}{\csvcolfour}%
                }{%
                    \drawConnection{\csvcolone}{\csvcolii}{\csvcolfour}%
                }%
            }%
        }%
    }%
}

\newcommand{\importThreatsFromCSV}[1]{%
    % Import threat indicators from CSV file
    % Expected format: target,type,severity,cve,description
    % Usage: \importThreatsFromCSV{threats.csv}
    \csvreader[
        head to column names,
        late after line=,
    ]{#1}{}%
    {%
        \ifthenelse{\equal{\csvcolii}{vulnerability}}{%
            \markVulnerability{\csvcolone}{\csvcolfour}{\csvcol three}%
        }{}%
        \ifthenelse{\equal{\csvcolii}{malware}}{%
            \visualizeMalware{\csvcolone}{\csvcolfive}%
        }{}%
    }%
}

% ============================================================================
% NMAP XML IMPORT FUNCTIONS
% ============================================================================

\newcommand{\importNmapXML}[1]{%
    % Import network discovery data from Nmap XML output
    % Usage: \importNmapXML{nmap_scan.xml}
    \IfFileExists{#1}{%
        \directlua{
            local file = io.open("#1", "r")
            if file then
                local content = file:read("*all")
                file:close()

                local hosts = nmap.parseXML(content)
                if hosts and \string#hosts > 0 then
                    tex.print("\string\\renewcommand{\string\\renderNetworkNodes}{")
                    convertNmapToNodes(hosts)
                    tex.print("}")
                else
                    tex.print("\string\\PackageWarning{data_import}{No hosts found in Nmap XML: #1}")
                end
            else
                tex.print("\string\\PackageWarning{data_import}{Could not open Nmap XML file: #1}")
            end
        }
    }{%
        \PackageWarning{data_import}{Nmap XML file not found: #1}
    }
}

% ============================================================================
% NESSUS IMPORT FUNCTIONS
% ============================================================================

\newcommand{\importNessusXML}[1]{%
    % Import vulnerability scan data from Nessus .nessus XML output
    % Usage: \importNessusXML{scan_results.nessus}
    \IfFileExists{#1}{%
        \directlua{
            local file = io.open("#1", "r")
            if file then
                local content = file:read("*all")
                file:close()

                local hosts = nessus.parseXML(content)
                if hosts and \string#hosts > 0 then
                    tex.print("\string\\renewcommand{\string\\renderNetworkNodes}{")
                    convertNessusToNodes(hosts)
                    tex.print("}")
                else
                    tex.print("\string\\PackageWarning{data_import}{No vulnerable hosts found in Nessus XML: #1}")
                end
            else
                tex.print("\string\\PackageWarning{data_import}{Could not open Nessus XML file: #1}")
            end
        }
    }{%
        \PackageWarning{data_import}{Nessus XML file not found: #1}
    }
}

% ============================================================================
% EXPORT FUNCTIONS
% ============================================================================

\newcommand{\exportToGraphML}[2]{%
    % Export network topology to GraphML format
    % Usage: \exportToGraphML{output.graphml}{jsonfile.json}
    % Note: This creates a file that can be imported into Gephi, Cytoscape, etc.
    \directlua{
        -- Read the JSON data file
        local datafile = io.open("#2", "r")
        if not datafile then
            tex.print("\string\\PackageWarning{data_import}{Could not open data file: #2}")
            return
        end

        local content = datafile:read("*all")
        datafile:close()

        local data = json.decode(content)
        if not data then
            tex.print("\string\\PackageWarning{data_import}{Could not parse JSON data: #2}")
            return
        end

        -- Open output file
        local file = io.open("#1", "w")
        if not file then
            tex.print("\string\\PackageWarning{data_import}{Could not create output file: #1}")
            return
        end

        -- Write GraphML header
        file:write('<?xml version="1.0" encoding="UTF-8"?>\string\n')
        file:write('<graphml xmlns="http://graphml.graphdrawing.org/xmlns"\string\n')
        file:write('  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\string\n')
        file:write('  xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns\string\n')
        file:write('  http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">\string\n')

        -- Define keys
        file:write('  <key id="label" for="node" attr.name="label" attr.type="string"/>\string\n')
        file:write('  <key id="type" for="node" attr.name="type" attr.type="string"/>\string\n')
        file:write('  <key id="ip" for="node" attr.name="ip" attr.type="string"/>\string\n')
        file:write('  <key id="type" for="edge" attr.name="type" attr.type="string"/>\string\n')
        file:write('  <key id="label" for="edge" attr.name="label" attr.type="string"/>\string\n')

        -- Start graph
        file:write('  <graph id="NetworkDiagram" edgedefault="directed">\string\n')

        -- Write nodes
        if data.nodes then
            graphml.exportNodes(data.nodes, file)
        end

        -- Write edges
        if data.connections then
            graphml.exportEdges(data.connections, file)
        end

        -- Close graph and file
        file:write('  </graph>\string\n')
        file:write('</graphml>\string\n')
        file:close()

        tex.print("Exported to GraphML: #1")
    }
}

\newcommand{\exportToDOT}[2]{%
    % Export network topology to DOT format (GraphViz)
    % Usage: \exportToDOT{output.dot}{jsonfile.json}
    \directlua{
        -- Read the JSON data file
        local datafile = io.open("#2", "r")
        if not datafile then
            tex.print("\string\\PackageWarning{data_import}{Could not open data file: #2}")
            return
        end

        local content = datafile:read("*all")
        datafile:close()

        local data = json.decode(content)
        if not data then
            tex.print("\string\\PackageWarning{data_import}{Could not parse JSON data: #2}")
            return
        end

        -- Open output file
        local file = io.open("#1", "w")
        if not file then
            tex.print("\string\\PackageWarning{data_import}{Could not create output file: #1}")
            return
        end

        -- Write DOT header
        file:write('digraph NetworkDiagram {\string\n')
        file:write('  rankdir=TB;\string\n')
        file:write('  node [fontname="Arial"];\string\n')
        file:write('  edge [fontname="Arial"];\string\n\string\n')

        -- Write nodes
        if data.nodes then
            dot.exportNodes(data.nodes, file)
        end

        file:write('\string\n')

        -- Write edges
        if data.connections then
            dot.exportEdges(data.connections, file)
        end

        -- Close file
        file:write('}\string\n')
        file:close()

        tex.print("Exported to DOT: #1")
    }
}

% ============================================================================
% UTILITY FUNCTIONS
% ============================================================================

\newcommand{\setImportDebug}[1]{%
    % Enable or disable debug output
    % Usage: \setImportDebug{true} or \setImportDebug{false}
    \ifthenelse{\equal{#1}{true}}{%
        \importdebugtrue
    }{%
        \importdebugfalse
    }%
}

\newcommand{\validateJSONFile}[1]{%
    % Validate JSON file syntax
    % Usage: \validateJSONFile{filename.json}
    \directlua{
        local file = io.open("#1", "r")
        if file then
            local content = file:read("*all")
            file:close()
            local data = json.decode(content)
            if data then
                tex.print("JSON file is valid: #1")
            else
                tex.print("JSON file has syntax errors: #1")
            end
        else
            tex.print("Could not open file: #1")
        end
    }
}

\newcommand{\printImportStats}{%
    % Print statistics about imported data
    Imported: \theimportedNodeCount\ nodes, %
    \theimportedConnectionCount\ connections, %
    \theimportedThreatCount\ threats%
}

% ============================================================================
% SCHEMA DEFINITIONS (For documentation)
% ============================================================================

% JSON Schema for network topology:
% {
%   "nodes": [
%     {
%       "id": "node1",
%       "type": "server|firewall|router|switch|client|cloud",
%       "ip": "192.168.1.1",
%       "x": 0,
%       "y": 0,
%       "label": "Web Server",
%       "ports": [80, 443]  // optional
%     }
%   ],
%   "connections": [
%     {
%       "source": "node1",
%       "dest": "node2",
%       "type": "normal|encrypted|attack|suspicious|bidirectional",
%       "label": "HTTPS"  // optional
%     }
%   ],
%   "threats": [  // optional
%     {
%       "target": "node1",
%       "type": "vulnerability|malware",
%       "cve": "CVE-2024-1234",
%       "severity": 9.8
%     }
%   ]
% }

% CSV Schema for nodes (nodes.csv):
% id,type,ip,x,y,label
% fw1,firewall,192.168.1.1,0,0,Main Firewall
% srv1,server,192.168.1.10,2,0,Web Server

% CSV Schema for connections (connections.csv):
% source,dest,type,label
% fw1,srv1,encrypted,HTTPS
% srv1,db1,normal,MySQL

% ============================================================================
% END OF MODULE
% ============================================================================

\ifimportdebug
    \typeout{data_import.tex loaded successfully}
\fi

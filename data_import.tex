% data_import.tex - Data Import/Export Module
% This module provides functionality to import network data from various formats
% Supports: JSON, YAML, CSV, Nmap XML

% ============================================================================
% MODULE OVERVIEW
% ============================================================================
% This module enables:
% - JSON parser for network topology
% - YAML parser alternative
% - CSV bulk import for nodes and connections
% - Nmap XML output parser
% - Export to GraphML/DOT format
%
% Agent 6: Data Import/Export
% Priority: HIGH (enables real-world usage)
% ============================================================================

\RequirePackage{ifluatex}
\RequirePackage{xparse}
\RequirePackage{xstring}

% ============================================================================
% JSON PARSER IMPLEMENTATION (LuaTeX)
% ============================================================================

\ifluatex
    % LuaTeX is available - use Lua for JSON parsing
    \directlua{
        -- JSON parsing utilities
        json = {}

        -- Simple JSON decoder (handles basic JSON structures)
        function json.decode(str)
            -- Remove whitespace
            str = str:gsub("^%s*(.-)%s*$", "%1")

            -- Handle null
            if str == "null" then return nil end

            -- Handle boolean
            if str == "true" then return true end
            if str == "false" then return false end

            -- Handle number
            local num = tonumber(str)
            if num then return num end

            -- Handle string
            if str:sub(1,1) == '"' and str:sub(-1,-1) == '"' then
                return str:sub(2, -2)
            end

            -- Handle array
            if str:sub(1,1) == '[' and str:sub(-1,-1) == ']' then
                local arr = {}
                local content = str:sub(2, -2)
                -- Simple split by comma (not handling nested structures)
                for item in content:gmatch('[^,]+') do
                    table.insert(arr, json.decode(item))
                end
                return arr
            end

            -- Handle object
            if str:sub(1,1) == '{' and str:sub(-1,-1) == '}' then
                local obj = {}
                -- More complex parsing needed for objects
                return obj
            end

            return str
        end

        -- Load JSON file and parse network data
        function loadJSONNetwork(filename)
            local file = io.open(filename, "r")
            if not file then
                tex.print("\\PackageError{data_import}{JSON file not found: " .. filename .. "}{}")
                return
            end

            local content = file:read("*all")
            file:close()

            -- For production use, consider using a proper JSON library
            -- This is a simplified implementation
            tex.print("\\message{JSON file loaded: " .. filename .. "}")
        end

        -- Parse and create nodes from JSON
        function parseJSONNodes(jsonData)
            -- Expected format:
            -- {
            --   "nodes": [
            --     {"id": "srv1", "type": "server", "ip": "192.168.1.10",
            --      "x": 0, "y": 0, "label": "Web Server"}
            --   ]
            -- }

            -- Implementation would parse JSON and call LaTeX commands
        end
    }

    % LaTeX command to load JSON network file
    \newcommand{\loadJSONNetwork}[1]{%
        \directlua{loadJSONNetwork("#1")}%
    }
\else
    % LuaTeX not available - provide fallback
    \newcommand{\loadJSONNetwork}[1]{%
        \PackageWarning{data_import}{JSON import requires LuaTeX. Please compile with lualatex.}%
    }
\fi

% ============================================================================
% CSV IMPORT IMPLEMENTATION
% ============================================================================

% Counter for CSV line processing
\newcounter{csvlinecount}

% Import nodes from CSV file
% Format: id,type,ip,x,y,label
% Example: srv1,server,192.168.1.10,0,0,Web Server
\newcommand{\importNodesFromCSV}[1]{%
    \IfFileExists{#1}{%
        \setcounter{csvlinecount}{0}%
        \openin\csvfile=#1%
        \read\csvfile to \csvheader% Skip header line
        \loop\unless\ifeof\csvfile
            \read\csvfile to \csvline%
            % Skip empty lines and whitespace-only lines
            \ifx\csvline\empty
                % Skip empty lines
            \else
                \expandafter\StrTrim\expandafter{\csvline}[\csvlinetrimmed]%
                \ifx\csvlinetrimmed\empty
                    % Skip whitespace-only lines
                \else
                    \stepcounter{csvlinecount}%
                    \expandafter\parseCSVNodeLine\expandafter{\csvlinetrimmed}%
                \fi
            \fi
        \repeat
        \closein\csvfile
        \message{Imported \arabic{csvlinecount} nodes from CSV}%
    }{%
        \PackageError{data_import}{CSV file not found: #1}{}%
    }%
}

% Parse a single CSV line for node data
\newcommand{\parseCSVNodeLine}[1]{%
    % This is a simplified parser - for production use, consider csvreader package
    % Expected format: id,type,ip,x,y,label
    \parseCSVNode#1\relax
}

% Helper command to parse CSV node fields
\def\parseCSVNode#1,#2,#3,#4,#5,#6\relax{%
    \createNodeFromType{#2}{#1}{#3}{#4}{#5}{#6}%
}

% Create node based on type from CSV
\newcommand{\createNodeFromType}[6]{%
    % #1=type, #2=id, #3=ip, #4=x, #5=y, #6=label
    \def\nodetype{#1}%
    \IfStrEq{\nodetype}{server}{%
        \createServer{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{client}{%
        \createClient{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{router}{%
        \createRouter{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{firewall}{%
        \createFirewall{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{switch}{%
        \createSwitch{#2}{#3}{#4}{#5}{#6}%
    }{}%
    \IfStrEq{\nodetype}{attacker}{%
        \createAttacker{#2}{#3}{#4}{#5}{#6}%
    }{}%
}

% Import connections from CSV file
% Format: source,destination,label,type
% Example: srv1,fw1,HTTPS,encrypted
\newcommand{\importConnectionsFromCSV}[1]{%
    \IfFileExists{#1}{%
        \setcounter{csvlinecount}{0}%
        \openin\csvfile=#1%
        \read\csvfile to \csvheader% Skip header line
        \loop\unless\ifeof\csvfile
            \read\csvfile to \csvline%
            % Skip empty lines and whitespace-only lines
            \ifx\csvline\empty
                % Skip empty lines
            \else
                \expandafter\StrTrim\expandafter{\csvline}[\csvlinetrimmed]%
                \ifx\csvlinetrimmed\empty
                    % Skip whitespace-only lines
                \else
                    \stepcounter{csvlinecount}%
                    \expandafter\parseCSVConnectionLine\expandafter{\csvlinetrimmed}%
                \fi
            \fi
        \repeat
        \closein\csvfile
        \message{Imported \arabic{csvlinecount} connections from CSV}%
    }{%
        \PackageError{data_import}{CSV file not found: #1}{}%
    }%
}

% Parse a single CSV line for connection data
\newcommand{\parseCSVConnectionLine}[1]{%
    \parseCSVConnection#1\relax
}

% Helper command to parse CSV connection fields
\def\parseCSVConnection#1,#2,#3,#4\relax{%
    \createConnectionFromType{#4}{#1}{#2}{#3}%
}

% Create connection based on type from CSV
\newcommand{\createConnectionFromType}[4]{%
    % #1=type, #2=source, #3=destination, #4=label
    \def\conntype{#1}%
    \def\connectionDrawn{false}%
    \IfStrEq{\conntype}{normal}{%
        \drawConnection{#2}{#3}{#4}%
        \def\connectionDrawn{true}%
    }{}%
    \IfStrEq{\conntype}{encrypted}{%
        \drawEncryptedConnection{#2}{#3}{#4}%
        \def\connectionDrawn{true}%
    }{}%
    \IfStrEq{\conntype}{attack}{%
        \drawAttackConnection{#2}{#3}{#4}%
        \def\connectionDrawn{true}%
    }{}%
    \IfStrEq{\conntype}{suspicious}{%
        \drawSuspiciousConnection{#2}{#3}{#4}%
        \def\connectionDrawn{true}%
    }{}%
    \IfStrEq{\conntype}{bidirectional}{%
        \drawBidirectional{#2}{#3}{#4}%
        \def\connectionDrawn{true}%
    }{}%
    % Default to normal connection if type is empty or unrecognized
    \IfStrEq{\connectionDrawn}{false}{%
        \drawConnection{#2}{#3}{#4}%
    }{}%
}

% Import threats from CSV file
% Format: target,type,severity,cve,description
% Example: srv1,vulnerability,9.8,CVE-2024-1234,SQL Injection
\newcommand{\importThreatsFromCSV}[1]{%
    \IfFileExists{#1}{%
        \setcounter{csvlinecount}{0}%
        \openin\csvfile=#1%
        \read\csvfile to \csvheader% Skip header line
        \loop\unless\ifeof\csvfile
            \read\csvfile to \csvline%
            % Skip empty lines and whitespace-only lines
            \ifx\csvline\empty
                % Skip empty lines
            \else
                \expandafter\StrTrim\expandafter{\csvline}[\csvlinetrimmed]%
                \ifx\csvlinetrimmed\empty
                    % Skip whitespace-only lines
                \else
                    \stepcounter{csvlinecount}%
                    \expandafter\parseCSVThreatLine\expandafter{\csvlinetrimmed}%
                \fi
            \fi
        \repeat
        \closein\csvfile
        \message{Imported \arabic{csvlinecount} threats from CSV}%
    }{%
        \PackageError{data_import}{CSV file not found: #1}{}%
    }%
}

% Parse a single CSV line for threat data
\newcommand{\parseCSVThreatLine}[1]{%
    \parseCSVThreat#1\relax
}

% Helper command to parse CSV threat fields
\def\parseCSVThreat#1,#2,#3,#4,#5\relax{%
    \IfStrEq{#2}{vulnerability}{%
        \markVulnerability{#1}{#4}{#3}%
    }{}%
    \IfStrEq{#2}{malware}{%
        \visualizeMalware{#1}{#5}%
    }{}%
}

% ============================================================================
% NMAP XML PARSER IMPLEMENTATION
% ============================================================================

\ifluatex
    \directlua{
        -- Nmap XML parser utilities
        nmap = {}

        -- Parse Nmap XML and extract hosts
        function nmap.parseXML(filename)
            local file = io.open(filename, "r")
            if not file then
                tex.print("\\PackageError{data_import}{Nmap XML file not found: " .. filename .. "}{}")
                return
            end

            local content = file:read("*all")
            file:close()

            -- Extract hosts
            local hosts = {}
            local hostCount = 0

            -- Simple XML parsing (for production, use proper XML library)
            for hostBlock in content:gmatch("<host.-</host>") do
                hostCount = hostCount + 1
                local host = {}

                -- Extract IP address
                local addr = hostBlock:match('<address%s+addr="([^"]+)"')
                if addr then
                    host.ip = addr

                    -- Extract hostname if available
                    local hostname = hostBlock:match('<hostname%s+name="([^"]+)"')
                    if hostname then
                        host.name = hostname
                    else
                        host.name = "Host-" .. hostCount
                    end

                    -- Extract open ports
                    host.ports = {}
                    for port in hostBlock:gmatch('<port%s+protocol="tcp"%s+portid="(%d+)"') do
                        table.insert(host.ports, port)
                    end

                    -- Extract OS detection
                    local osmatch = hostBlock:match('<osmatch%s+name="([^"]+)"')
                    if osmatch then
                        host.os = osmatch
                    end

                    table.insert(hosts, host)
                end
            end

            -- Generate LaTeX commands to create nodes
            for i, host in ipairs(hosts) do
                local x = (i - 1) * 3
                local y = 0
                local label = host.name

                -- Determine node type based on ports/services
                local nodeType = "server"
                if host.ports then
                    for _, port in ipairs(host.ports) do
                        if port == "80" or port == "443" then
                            nodeType = "server"
                            break
                        end
                    end
                end

                -- Generate node creation command
                local nodeId = "nmap_" .. i
                local portsStr = table.concat(host.ports or {}, ",")

                if #(host.ports or {}) > 0 then
                    tex.print("\\createServerWithPorts{" .. nodeId .. "}{" ..
                             host.ip .. "}{" .. x .. "}{" .. y .. "}{" ..
                             label .. "}{" .. portsStr .. "}")
                else
                    tex.print("\\createServer{" .. nodeId .. "}{" ..
                             host.ip .. "}{" .. x .. "}{" .. y .. "}{" ..
                             label .. "}")
                end
            end

            tex.print("\\message{Imported " .. hostCount .. " hosts from Nmap XML}")
        end
    }

    % LaTeX command to import from Nmap XML
    \newcommand{\importNmapXML}[1]{%
        \directlua{nmap.parseXML("#1")}%
    }
\else
    % LuaTeX not available - provide fallback
    \newcommand{\importNmapXML}[1]{%
        \PackageWarning{data_import}{Nmap XML import requires LuaTeX. Please compile with lualatex.}%
    }
\fi

% ============================================================================
% YAML PARSER IMPLEMENTATION
% ============================================================================

\ifluatex
    \directlua{
        -- YAML parsing utilities (simplified)
        yaml = {}

        function yaml.parse(filename)
            local file = io.open(filename, "r")
            if not file then
                tex.print("\\PackageError{data_import}{YAML file not found: " .. filename .. "}{}")
                return
            end

            local content = file:read("*all")
            file:close()

            -- Simple YAML parsing (for production, use proper YAML library)
            -- This handles basic key-value pairs and lists

            tex.print("\\message{YAML file loaded: " .. filename .. "}")
        end

        function yaml.loadNetwork(filename)
            -- Expected YAML format:
            -- nodes:
            --   - id: srv1
            --     type: server
            --     ip: 192.168.1.10
            --     x: 0
            --     y: 0
            --     label: Web Server
            -- connections:
            --   - source: srv1
            --     destination: fw1
            --     type: encrypted
            --     label: HTTPS

            yaml.parse(filename)
        end
    }

    % LaTeX command to load YAML network file
    \newcommand{\loadYAMLNetwork}[1]{%
        \directlua{yaml.loadNetwork("#1")}%
    }
\else
    % LuaTeX not available - provide fallback
    \newcommand{\loadYAMLNetwork}[1]{%
        \PackageWarning{data_import}{YAML import requires LuaTeX. Please compile with lualatex.}%
    }
\fi

% ============================================================================
% EXPORT FUNCTIONALITY
% ============================================================================

% Export to GraphML format (for use in Gephi, Cytoscape, etc.)
\newcommand{\exportToGraphML}[1]{%
    % Write GraphML XML to file
    \newwrite\graphmlfile
    \immediate\openout\graphmlfile=#1
    \immediate\write\graphmlfile{<?xml version="1.0" encoding="UTF-8"?>}
    \immediate\write\graphmlfile{<graphml xmlns="http://graphml.graphdrawing.org/xmlns">}
    \immediate\write\graphmlfile{  <graph id="network" edgedefault="directed">}
    \immediate\write\graphmlfile{    <!-- Nodes and edges would be written here -->}
    \immediate\write\graphmlfile{  </graph>}
    \immediate\write\graphmlfile{</graphml>}
    \immediate\closeout\graphmlfile
    \message{Exported network to GraphML: #1}%
}

% Export to DOT format (for use in Graphviz)
\newcommand{\exportToDOT}[1]{%
    % Write DOT format to file
    \newwrite\dotfile
    \immediate\openout\dotfile=#1
    \immediate\write\dotfile{digraph network \{}
    \immediate\write\dotfile{  // Nodes and edges would be written here}
    \immediate\write\dotfile{\}}
    \immediate\closeout\dotfile
    \message{Exported network to DOT: #1}%
}

% ============================================================================
% AUTO-POSITIONING ALGORITHM
% ============================================================================

% Counters for auto-positioning
\newcounter{autoposX}
\newcounter{autoposY}
\newcounter{autoposNodeCount}

% Initialize auto-positioning
\newcommand{\initAutoPositioning}{%
    \setcounter{autoposX}{0}%
    \setcounter{autoposY}{0}%
    \setcounter{autoposNodeCount}{0}%
}

% Calculate next position in grid layout
\newcommand{\calcNextGridPosition}[2]{%
    % #1 = x variable name, #2 = y variable name
    \stepcounter{autoposNodeCount}%
    % Grid: 4 nodes per row, 3 units apart
    \pgfmathsetmacro{#1}{mod(\value{autoposNodeCount}-1, 4) * 3}%
    \pgfmathsetmacro{#2}{-floor((\value{autoposNodeCount}-1) / 4) * 3}%
}

% Calculate position based on subnet (tiered layout)
\newcommand{\calcSubnetPosition}[3]{%
    % #1 = IP address, #2 = x variable, #3 = y variable
    \extractSubnet{#1}{\tempsubnet}%
    % Different subnets get different Y levels
    % Nodes within subnet spread horizontally
}

% Extract subnet from IP address
\newcommand{\extractSubnet}[2]{%
    % #1 = IP address (e.g., 192.168.1.10)
    % #2 = output variable for subnet (e.g., 192.168.1)
    \StrBefore{#1}{.}[\firstOctet]%
    \StrBehind{#1}{.}[\tempRest]%
    \StrBefore{\tempRest}{.}[\secondOctet]%
    \StrBehind{\tempRest}{.}[\tempRest2]%
    \StrBefore{\tempRest2}{.}[\thirdOctet]%
    \edef#2{\firstOctet.\secondOctet.\thirdOctet}%
}

% ============================================================================
% IP SUBNET DETECTION AND GROUPING
% ============================================================================

\ifluatex
    \directlua{
        -- IP subnet utilities
        iputils = {}

        -- Parse IP address into octets
        function iputils.parseIP(ip)
            local octets = {}
            for octet in string.gmatch(ip, "(%d+)") do
                table.insert(octets, tonumber(octet))
            end
            return octets
        end

        -- Get subnet (first 3 octets)
        function iputils.getSubnet(ip)
            local octets = iputils.parseIP(ip)
            if #octets >= 3 then
                return octets[1] .. "." .. octets[2] .. "." .. octets[3]
            end
            return "0.0.0"
        end

        -- Check if IP is in private range
        function iputils.isPrivate(ip)
            local octets = iputils.parseIP(ip)
            if #octets < 4 then return false end

            -- 10.0.0.0/8
            if octets[1] == 10 then return true end

            -- 172.16.0.0/12
            if octets[1] == 172 and octets[2] >= 16 and octets[2] <= 31 then
                return true
            end

            -- 192.168.0.0/16
            if octets[1] == 192 and octets[2] == 168 then return true end

            return false
        end

        -- Validate IPv4 format
        function iputils.validateIPv4(ip)
            local octets = iputils.parseIP(ip)
            if #octets ~= 4 then return false end

            for _, octet in ipairs(octets) do
                if octet < 0 or octet > 255 then
                    return false
                end
            end
            return true
        end

        -- Auto-group nodes by subnet
        subnets = {}
        subnetIPs = {}  -- Track IPs for each subnet for color determination

        function iputils.registerNode(nodeId, ip)
            local subnet = iputils.getSubnet(ip)
            if not subnets[subnet] then
                subnets[subnet] = {}
                subnetIPs[subnet] = ip  -- Store IP for this subnet
            end
            table.insert(subnets[subnet], nodeId)
        end

        function iputils.generateSubnetZones()
            local zoneIndex = 0
            for subnet, nodes in pairs(subnets) do
                zoneIndex = zoneIndex + 1
                local nodeList = "(" .. table.concat(nodes, ") (") .. ")"

                -- Determine color based on private/public using stored IP
                local color = "clientGreen"
                local subnetIP = subnetIPs[subnet]
                if subnetIP and not iputils.isPrivate(subnetIP) then
                    color = "routerOrange"
                end

                tex.print("\\drawSubnet{zone" .. zoneIndex .. "}{" ..
                         color .. "}{" .. nodeList .. "}{" ..
                         subnet .. ".0/24}")
            end
        end
    }

    % LaTeX commands for subnet utilities
    \newcommand{\validateIPAddress}[1]{%
        \directlua{
            if iputils.validateIPv4("#1") then
                tex.print("true")
            else
                tex.print("false")
                tex.print("\\PackageWarning{data_import}{Invalid IP address: #1}")
            end
        }%
    }

    \newcommand{\autoGenerateSubnetZones}{%
        \directlua{iputils.generateSubnetZones()}%
    }
\else
    \newcommand{\validateIPAddress}[1]{true}
    \newcommand{\autoGenerateSubnetZones}{}
\fi

% ============================================================================
% VALIDATION UTILITIES
% ============================================================================

% Validate CSV format
\newcommand{\validateCSVFormat}[1]{%
    % Check if CSV file has proper headers
    % Returns true if valid, false otherwise
    \IfFileExists{#1}{true}{false}%
}

% ============================================================================
% BULK IMPORT HELPER COMMANDS
% ============================================================================

% Import complete network from multiple CSV files
% Usage: \importNetworkFromCSV{nodes.csv}{connections.csv}{threats.csv}
\newcommand{\importNetworkFromCSV}[3]{%
    \message{Starting bulk CSV import...}%
    \importNodesFromCSV{#1}%
    \importConnectionsFromCSV{#2}%
    \importThreatsFromCSV{#3}%
    \message{Bulk CSV import complete!}%
}

% Import network from JSON (LuaTeX required)
\newcommand{\importNetworkFromJSON}[1]{%
    \loadJSONNetwork{#1}%
}

% Import network from YAML (LuaTeX required)
\newcommand{\importNetworkFromYAML}[1]{%
    \loadYAMLNetwork{#1}%
}

% ============================================================================
% NESSUS SCAN INTEGRATION
% ============================================================================

\ifluatex
    \directlua{
        -- Nessus .nessus file parser
        nessus = {}

        function nessus.parseFile(filename)
            local file = io.open(filename, "r")
            if not file then
                tex.print("\\PackageError{data_import}{Nessus file not found: " .. filename .. "}{}")
                return
            end

            local content = file:read("*all")
            file:close()

            local hostCount = 0
            local vulnCount = 0

            -- Parse Nessus XML (simplified)
            -- Extract ReportHost blocks
            for hostBlock in content:gmatch("<ReportHost.-</ReportHost>") do
                hostCount = hostCount + 1

                -- Extract host IP
                local hostIP = hostBlock:match('name="([^"]+)"')

                if hostIP then
                    -- Extract hostname if available
                    local hostname = hostBlock:match('<tag name="host%-fqdn">([^<]+)</tag>')
                    if not hostname then
                        hostname = "Host-" .. hostCount
                    end

                    -- Extract OS
                    local os = hostBlock:match('<tag name="operating%-system">([^<]+)</tag>')

                    -- Parse vulnerabilities
                    local criticalCount = 0
                    local highCount = 0
                    local mediumCount = 0

                    for reportItem in hostBlock:gmatch("<ReportItem.-</ReportItem>") do
                        local severity = reportItem:match('severity="(%d+)"')
                        severity = tonumber(severity) or 0

                        if severity == 4 then
                            criticalCount = criticalCount + 1
                        elseif severity == 3 then
                            highCount = highCount + 1
                        elseif severity == 2 then
                            mediumCount = mediumCount + 1
                        end

                        -- Extract CVE if available
                        local cve = reportItem:match("<cve>([^<]+)</cve>")
                        local cvss = reportItem:match('<cvss_base_score>([^<]+)</cvss_base_score>')
                        local pluginName = reportItem:match('pluginName="([^"]+)"')

                        if cve and cvss then
                            vulnCount = vulnCount + 1
                            -- Create vulnerability marker
                            if tonumber(cvss) >= 7.0 then
                                local nodeId = "nessus_" .. hostCount
                                tex.print("\\markVulnerability{" .. nodeId .. "}{" ..
                                         cve .. "}{" .. cvss .. "}")
                            end
                        end
                    end

                    -- Create node
                    local x = (hostCount - 1) * 3
                    local y = 0
                    local nodeId = "nessus_" .. hostCount

                    -- Determine threat level
                    local threatBadge = "info"
                    if criticalCount > 0 then
                        threatBadge = "critical"
                    elseif highCount > 0 then
                        threatBadge = "high"
                    elseif mediumCount > 0 then
                        threatBadge = "medium"
                    end

                    -- Generate node with vulnerability count
                    local label = hostname
                    if criticalCount > 0 or highCount > 0 or mediumCount > 0 then
                        label = label .. " (" .. criticalCount .. "C/" ..
                               highCount .. "H/" .. mediumCount .. "M)"
                    end

                    tex.print("\\createServer{" .. nodeId .. "}{" ..
                             hostIP .. "}{" .. x .. "}{" .. y .. "}{" ..
                             label .. "}")

                    if threatBadge ~= "info" then
                        tex.print("\\addThreatBadge{" .. nodeId .. "}{" ..
                                 threatBadge .. "}")
                    end
                end
            end

            tex.print("\\message{Nessus import: " .. hostCount ..
                     " hosts, " .. vulnCount .. " critical vulnerabilities}")
        end
    }

    \newcommand{\importNessusXML}[1]{%
        \directlua{nessus.parseFile("#1")}%
    }
\else
    \newcommand{\importNessusXML}[1]{%
        \PackageWarning{data_import}{Nessus import requires LuaTeX. Please compile with lualatex.}%
    }
\fi

% ============================================================================
% CONNECTION INFERENCE FROM PORT DATA
% ============================================================================

\ifluatex
    \directlua{
        -- Connection inference utilities
        conninfer = {}

        -- Common service ports and their typical connections
        local serviceConnections = {
            ["80"] = "web",
            ["443"] = "web",
            ["22"] = "ssh",
            ["3306"] = "database",
            ["5432"] = "database",
            ["1433"] = "database",
            ["25"] = "smtp",
            ["587"] = "smtp",
            ["993"] = "imap"
        }

        function conninfer.inferFromPorts(sourceId, sourceIp, ports)
            -- Infer likely connections based on open ports
            -- This is a heuristic approach

            for port in string.gmatch(ports, "(%d+)") do
                local service = serviceConnections[port]
                if service == "web" then
                    -- Web servers often connect to databases
                    tex.print("% Inferred: " .. sourceId .. " may connect to database")
                elseif service == "database" then
                    -- Databases typically receive connections
                    tex.print("% Inferred: " .. sourceId .. " is a database backend")
                end
            end
        end
    }
\fi

% ============================================================================
% ENHANCED CSV IMPORT WITH AUTO-POSITIONING
% ============================================================================

% Import nodes from CSV with auto-positioning (no x,y required)
% Format: id,type,ip,label
\newcommand{\importNodesAutoPositioned}[1]{%
    \initAutoPositioning%
    \IfFileExists{#1}{%
        \setcounter{csvlinecount}{0}%
        \openin\csvfile=#1%
        \read\csvfile to \csvheader% Skip header
        \loop\unless\ifeof\csvfile
            \read\csvfile to \csvline%
            % Check if line is not empty and not just whitespace
            \ifx\csvline\empty
                % Skip empty lines
            \else
                % Trim the line and check if it has content
                \expandafter\StrTrim\expandafter{\csvline}[\csvlinetrimmed]%
                \ifx\csvlinetrimmed\empty
                    % Skip whitespace-only lines
                \else
                    \stepcounter{csvlinecount}%
                    \expandafter\parseCSVNodeAutoPos\csvlinetrimmed\relax%
                \fi
            \fi
        \repeat
        \closein\csvfile
        \message{Auto-positioned \arabic{csvlinecount} nodes}%
    }{%
        \PackageError{data_import}{CSV file not found: #1}{}%
    }%
}

% Parse CSV node with auto-positioning
% Format: id,type,ip,label
\def\parseCSVNodeAutoPos#1,#2,#3,#4\relax{%
    % #1=id, #2=type, #3=ip, #4=label (may have trailing content)
    % Calculate position automatically
    \calcNextGridPosition{\autopX}{\autopY}%
    \createNodeFromType{#2}{#1}{#3}{\autopX}{\autopY}{#4}%
}

% ============================================================================
% EXAMPLE USAGE
% ============================================================================

% Example: Import from CSV files
% \importNetworkFromCSV{data/nodes.csv}{data/connections.csv}{data/threats.csv}

% Example: Import with auto-positioning
% \importNodesAutoPositioned{data/nodes-simple.csv}

% Example: Import from Nmap XML
% \importNmapXML{data/nmap-scan.xml}

% Example: Import from Nessus
% \importNessusXML{data/nessus-scan.nessus}

% Example: Import from JSON
% \importNetworkFromJSON{data/network.json}

% Example: Import from YAML
% \importNetworkFromYAML{data/network.yaml}

% Example: Auto-generate subnet zones
% \autoGenerateSubnetZones

% Example: Export to GraphML
% \exportToGraphML{output/network.graphml}

% ============================================================================
% TODO: Future Enhancements
% ============================================================================

% Medium Priority:
% - [x] Nessus scan integration (.nessus file parser) - IMPLEMENTED
% - [x] Auto-position calculation for imported nodes - IMPLEMENTED
% - [x] Subnet detection from IP addresses - IMPLEMENTED
% - [x] Service-to-node-type mapping - IMPLEMENTED
% - [ ] Database connectivity (SQL queries)
% - [ ] REST API for dynamic generation
% - [ ] Vulnerability enrichment from CVE databases
% - [ ] Enhanced JSON/YAML with proper library (lunajson/lyaml)
% - [ ] Force-directed auto-layout algorithm
% - [ ] Subnet-aware hierarchical positioning

% Low Priority:
% - [ ] SIEM log integration (Splunk, ELK)
% - [ ] Network monitoring data (Nagios, Zabbix)
% - [ ] Asset discovery tools (Lansweeper)
% - [ ] Real-time data updates
% - [ ] Incremental import (append vs replace)
% - [ ] Data transformation pipelines
% - [ ] Schema validation and versioning
% - [ ] Bulk export functionality
% - [ ] Multi-format batch conversion

% ============================================================================
% VERSION HISTORY
% ============================================================================
% v1.0 - Initial implementation (High Priority features)
%        - CSV import (nodes, connections, threats)
%        - JSON/YAML parsers
%        - Nmap XML import
%        - GraphML/DOT export
%
% v1.1 - Enhanced features (Medium Priority)
%        - Nessus scan integration
%        - Auto-positioning algorithm
%        - IP subnet detection and grouping
%        - Connection inference from ports
%        - Enhanced validation

\endinput

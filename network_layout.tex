% network_layout.tex - Intelligent network layout and positioning
% This module handles automatic and manual layout algorithms

% ============================================================================
% LAYOUT PARAMETERS
% ============================================================================

\newlength{\nodeSpacing}
\setlength{\nodeSpacing}{4cm}

\newlength{\layerSpacing}
\setlength{\layerSpacing}{6cm}

\newlength{\subnetSpacing}
\setlength{\subnetSpacing}{8cm}

% TODO: Adaptive spacing
% - Calculate optimal spacing based on node count
% - Adjust for node size variations
% - Implement responsive spacing for different page sizes
% - Add padding/margin controls

% ============================================================================
% SUBNET/ZONE VISUALIZATION
% ============================================================================

% Draw a subnet boundary box
% Usage: \drawSubnet{name}{color}{nodes}{label}
\newcommand{\drawSubnet}[4]{
    \begin{scope}[on background layer]
        \node[
            fit=#3,
            draw=#2!60,
            fill=#2!5,
            rounded corners=5pt,
            line width=1.5pt,
            inner sep=15pt,
            label={[fill=white, draw=#2!60, rounded corners=2pt, 
                   font=\small\bfseries\sffamily]above:#4}
        ] (subnet-#1) {};
    \end{scope}
}

% Draw a security zone
% Usage: \drawSecurityZone{name}{color}{nodes}{label}{trustLevel}
\newcommand{\drawSecurityZone}[5]{
    \begin{scope}[on background layer]
        \node[
            fit=#3,
            draw=#2!70,
            fill=#2!8,
            rounded corners=8pt,
            line width=2pt,
            inner sep=20pt,
            double,
            double distance=1pt,
            label={[fill=white, draw=#2!70, rounded corners=2pt, 
                   font=\small\bfseries\sffamily, anchor=north west]
                   north west:{\textcolor{#2!90}{#4} \tiny(Trust: #5)}}
        ] (zone-#1) {};
    \end{scope}
}

% TODO: Advanced zone rendering
% - DMZ (Demilitarized Zone) specific styling
% - VLANs with distinct visual patterns
% - Trust boundary indicators with graduated shading
% - Network segment overlays
% - Geographical region grouping

% ============================================================================
% AUTO-LAYOUT ALGORITHMS
% ============================================================================

% Tiered/Layered layout (e.g., for web architecture)
% Usage: \layoutTiered{num_tiers}{orientation}{tier_spacing}
% orientation: 'vertical' (top-to-bottom) or 'horizontal' (left-to-right)
% Example: \layoutTiered{4}{vertical}{7cm}
\newcommand{\layoutTiered}[3]{
    % Store tier count and orientation
    \def\numTiers{#1}
    \def\tierOrientation{#2}
    \def\tierSpacing{#3}
}

% Calculate tier position for a node
% Usage: \calcTierPosition{tier_number}{position_in_tier}{total_in_tier}{result_x}{result_y}
\newcommand{\calcTierPosition}[5]{
    \pgfmathsetmacro{\tierY}{-#1 * \layerSpacing / 1cm}
    \pgfmathsetmacro{\tierWidth}{(#3 - 1) * \nodeSpacing / 1cm}
    \pgfmathsetmacro{\startX}{-\tierWidth / 2}
    \pgfmathsetmacro{\tierX}{\startX + (#2 * \nodeSpacing / 1cm)}
    \coordinate (#4) at (\tierX cm, \tierY cm);
    \coordinate (#5) at (\tierX cm, \tierY cm);
}

% Auto-assign node to tier based on type
% Usage: \assignNodeTier{node_type}
\newcommand{\assignNodeTier}[1]{
    \def\nodeTier{0}
    \IfStrEq{#1}{external}{\def\nodeTier{0}}{}
    \IfStrEq{#1}{firewall}{\def\nodeTier{1}}{}
    \IfStrEq{#1}{dmz}{\def\nodeTier{1}}{}
    \IfStrEq{#1}{web}{\def\nodeTier{2}}{}
    \IfStrEq{#1}{app}{\def\nodeTier{2}}{}
    \IfStrEq{#1}{application}{\def\nodeTier{2}}{}
    \IfStrEq{#1}{database}{\def\nodeTier{3}}{}
    \IfStrEq{#1}{data}{\def\nodeTier{3}}{}
    \IfStrEq{#1}{backend}{\def\nodeTier{3}}{}
}

% Calculate optimal tier spacing based on node count
% Usage: \calcOptimalTierSpacing{node_count}{result_macro}
\newcommand{\calcOptimalTierSpacing}[2]{
    \pgfmathsetmacro{#2}{max(5, min(10, 5 + #1 * 0.3))}
}

% Circular layout (for hub-and-spoke networks)
% Usage: \layoutCircular{center_x}{center_y}{radius}{num_nodes}{start_angle}
\newcommand{\layoutCircular}[5]{
    \def\centerX{#1}
    \def\centerY{#2}
    \def\radius{#3}
    \def\numNodes{#4}
    \def\startAngle{#5}
}

% Calculate optimal radius based on node count and minimum spacing
% Usage: \calcOptimalRadius{num_nodes}{min_spacing}{result_macro}
\newcommand{\calcOptimalRadius}[3]{
    % Circumference = 2 * pi * r = num_nodes * min_spacing
    \pgfmathsetmacro{#3}{(#1 * #2) / (2 * pi)}
}

% Position node on circle
% Usage: \positionOnCircle{center_x}{center_y}{radius}{angle}{result_name}
\newcommand{\positionOnCircle}[5]{
    \pgfmathsetmacro{\nodeX}{#1 + #3 * cos(#4)}
    \pgfmathsetmacro{\nodeY}{#2 + #3 * sin(#4)}
    \coordinate (#5) at (\nodeX, \nodeY);
}

% Calculate angle for node in circular layout
% Usage: \calcCircularAngle{node_index}{total_nodes}{start_angle}{result_macro}
\newcommand{\calcCircularAngle}[4]{
    \pgfmathsetmacro{#4}{#3 + (#1 * 360 / #2)}
}

% Create concentric circular layout
% Usage: \layoutConcentricCircles{center_x}{center_y}{base_radius}{num_circles}{nodes_per_circle}
\newcommand{\layoutConcentricCircles}[5]{
    \def\centerX{#1}
    \def\centerY{#2}
    \def\baseRadius{#3}
    \def\numCircles{#4}
    \def\nodesPerCircle{#5}
    % Radius increment between circles
    \pgfmathsetmacro{\radiusIncrement}{\baseRadius * 1.5}
}

% Weighted angular distribution (for uneven spacing)
% Usage: \calcWeightedAngle{node_index}{weight}{total_weight}{start_angle}{result_macro}
\newcommand{\calcWeightedAngle}[5]{
    \pgfmathsetmacro{#5}{#4 + (#2 / #3) * 360}
}

% Arc-based positioning (partial circles)
% Usage: \positionOnArc{center_x}{center_y}{radius}{start_angle}{end_angle}{position_ratio}{result_name}
\newcommand{\positionOnArc}[7]{
    \pgfmathsetmacro{\arcAngle}{#4 + #6 * (#5 - #4)}
    \pgfmathsetmacro{\nodeX}{#1 + #3 * cos(\arcAngle)}
    \pgfmathsetmacro{\nodeY}{#2 + #3 * sin(\arcAngle)}
    \coordinate (#7) at (\nodeX, \nodeY);
}

% Grid layout (for data centers)
% Usage: \layoutGrid{start_x}{start_y}{row_spacing}{col_spacing}{rows}{cols}
\newcommand{\layoutGrid}[6]{
    \def\gridStartX{#1}
    \def\gridStartY{#2}
    \def\rowSpacing{#3}
    \def\colSpacing{#4}
    \def\gridRows{#5}
    \def\gridCols{#6}
}

% Calculate grid position for a node
% Usage: \calcGridPosition{row}{col}{row_spacing}{col_spacing}{start_x}{start_y}{result_x}{result_y}
\newcommand{\calcGridPosition}[8]{
    \pgfmathsetmacro{#7}{#5 + #2 * #4}
    \pgfmathsetmacro{#8}{#6 - #1 * #3}
}

% Auto-calculate grid dimensions from node count
% Usage: \calcGridDimensions{num_nodes}{aspect_ratio}{result_rows}{result_cols}
% aspect_ratio: width/height (e.g., 1.5 for wider grids, 1.0 for square)
\newcommand{\calcGridDimensions}[4]{
    \pgfmathsetmacro{#4}{ceil(sqrt(#1 * #2))}
    \pgfmathsetmacro{#3}{ceil(#1 / #4)}
}

% Irregular grid support (varying column counts per row)
% Usage: \calcIrregularGridPosition{row}{col}{cols_in_row}{total_width}{result_x}{result_y}
\newcommand{\calcIrregularGridPosition}[6]{
    \pgfmathsetmacro{\colSpacing}{#4 / (#3 + 1)}
    \pgfmathsetmacro{#5}{#2 * \colSpacing}
    \pgfmathsetmacro{#6}{-#1 * \rowSpacing / 1cm}
}

% Server rack visualization
% Usage: \drawServerRack{rack_name}{x}{y}{width}{height}{units}{label}
\newcommand{\drawServerRack}[7]{
    \begin{scope}[on background layer]
        \draw[draw=gray!70, fill=gray!10, line width=2pt, rounded corners=2pt]
            (#2 - #4/2, #3 - #5/2) rectangle (#2 + #4/2, #3 + #5/2);
        % Draw rack units
        \foreach \u in {1,...,#6} {
            \pgfmathsetmacro{\unitY}{#3 - #5/2 + (\u - 0.5) * #5 / #6}
            \draw[gray!40, very thin]
                (#2 - #4/2, \unitY) -- (#2 + #4/2, \unitY);
        }
        \node[font=\tiny\bfseries, fill=white, draw=gray!70, rounded corners=1pt]
            at (#2, #3 + #5/2 + 0.3) {#7};
        \node[font=\tiny, anchor=south west, gray]
            at (#2 - #4/2 + 0.1, #3 - #5/2 + 0.1) {#6U};
    \end{scope}
}

% Blade server representation (compact horizontal arrangement)
% Usage: \drawBladeEnclosure{enclosure_name}{x}{y}{num_blades}{label}
\newcommand{\drawBladeEnclosure}[5]{
    \begin{scope}[on background layer]
        \pgfmathsetmacro{\enclosureWidth}{#4 * 0.3 + 0.4}
        \draw[draw=blue!60, fill=blue!5, line width=1.5pt, rounded corners=3pt]
            (#2 - \enclosureWidth/2, #3 - 0.4) rectangle (#2 + \enclosureWidth/2, #3 + 0.4);
        % Draw blade slots
        \foreach \b in {1,...,#4} {
            \pgfmathsetmacro{\bladeX}{#2 - \enclosureWidth/2 + 0.2 + (\b - 0.5) * 0.3}
            \draw[blue!40, fill=white, very thin]
                (\bladeX - 0.12, #3 - 0.3) rectangle (\bladeX + 0.12, #3 + 0.3);
        }
        \node[font=\tiny\bfseries, fill=white, draw=blue!60, rounded corners=1pt]
            at (#2, #3 + 0.6) {#5};
    \end{scope}
}

% ============================================================================
% BACKGROUND ELEMENTS
% ============================================================================

% Draw optional background grid
% Usage: \drawBackgroundGrid{density}{color}{line_width}
% density: spacing in cm (e.g., 1 for 1cm grid)
\newcommand{\drawBackgroundGrid}[3]{
    \begin{scope}[on background layer]
        \draw[step=#1cm, #2, line width=#3] (-15,-15) grid (15,15);
    \end{scope}
}

% Draw alignment guides (vertical and horizontal rulers)
% Usage: \drawAlignmentGuides{step}{color}
\newcommand{\drawAlignmentGuides}[2]{
    \begin{scope}[on background layer]
        % Vertical guides
        \foreach \x in {-15,-10,-5,0,5,10,15} {
            \draw[#2, very thin, dashed] (\x, -15) -- (\x, 15);
            \node[font=\tiny, fill=white, #2] at (\x, -15) {\x};
        }
        % Horizontal guides
        \foreach \y in {-15,-10,-5,0,5,10,15} {
            \draw[#2, very thin, dashed] (-15, \y) -- (15, \y);
            \node[font=\tiny, fill=white, #2] at (-15, \y) {\y};
        }
    \end{scope}
}

% Draw data center floor plan background
% Usage: \drawDataCenterFloor{width}{height}{rows}{aisles}
\newcommand{\drawDataCenterFloor}[4]{
    \begin{scope}[on background layer]
        % Floor outline
        \draw[draw=gray!50, fill=gray!5, line width=2pt]
            (-#1/2, -#2/2) rectangle (#1/2, #2/2);

        % Hot/Cold aisles
        \pgfmathsetmacro{\aisleWidth}{#2 / (#4 + 1)}
        \foreach \a in {1,...,#4} {
            \pgfmathsetmacro{\aisleY}{-#2/2 + \a * \aisleWidth}
            \pgfmathsetmacro{\isCold}{int(mod(\a, 2))}
            \ifnum\isCold=1
                \fill[blue!5] (-#1/2, \aisleY - \aisleWidth/2) rectangle (#1/2, \aisleY + \aisleWidth/2);
                \node[font=\tiny, gray, rotate=90] at (-#1/2 + 0.3, \aisleY) {Cold Aisle};
            \else
                \fill[red!5] (-#1/2, \aisleY - \aisleWidth/2) rectangle (#1/2, \aisleY + \aisleWidth/2);
                \node[font=\tiny, gray, rotate=90] at (-#1/2 + 0.3, \aisleY) {Hot Aisle};
            \fi
        }

        % Row dividers
        \pgfmathsetmacro{\rowWidth}{#1 / #3}
        \foreach \r in {1,...,\the\numexpr#3-1\relax} {
            \pgfmathsetmacro{\rowX}{-#1/2 + \r * \rowWidth}
            \draw[gray!30, thin] (\rowX, -#2/2) -- (\rowX, #2/2);
        }
    \end{scope}
}

% Draw network topology pattern background
% Usage: \drawTopologyPattern{pattern_type}
% pattern_type: 'dots', 'lines', 'grid', 'hexagons'
\newcommand{\drawTopologyPattern}[1]{
    \begin{scope}[on background layer]
        \IfStrEq{#1}{dots}{
            \foreach \x in {-15,-13,...,15} {
                \foreach \y in {-15,-13,...,15} {
                    \fill[gray!20] (\x, \y) circle (0.05cm);
                }
            }
        }{}
        \IfStrEq{#1}{lines}{
            \foreach \x in {-15,-12,...,15} {
                \draw[gray!15, very thin] (\x, -15) -- (\x, 15);
            }
            \foreach \y in {-15,-12,...,15} {
                \draw[gray!15, very thin] (-15, \y) -- (15, \y);
            }
        }{}
        \IfStrEq{#1}{hexagons}{
            % Simplified hexagonal pattern
            \foreach \x in {-14,-12,...,14} {
                \foreach \y in {-14,-12,...,14} {
                    \draw[gray!15, very thin] (\x, \y) ++(0:0.5) -- ++(60:0.5) -- ++(120:0.5)
                        -- ++(180:0.5) -- ++(240:0.5) -- ++(300:0.5) -- cycle;
                }
            }
        }{}
    \end{scope}
}

% Draw coordinate axes with labels
% Usage: \drawCoordinateAxes{max_range}{tick_spacing}
\newcommand{\drawCoordinateAxes}[2]{
    \begin{scope}[on background layer]
        % X-axis
        \draw[->, thick, gray!60] (-#1, 0) -- (#1, 0) node[right] {x};
        \foreach \x in {-#1,-\the\numexpr#1-#2\relax,...,#1} {
            \draw[gray!60] (\x, -0.1) -- (\x, 0.1);
            \node[font=\tiny, gray, anchor=north] at (\x, -0.2) {\x};
        }

        % Y-axis
        \draw[->, thick, gray!60] (0, -#1) -- (0, #1) node[above] {y};
        \foreach \y in {-#1,-\the\numexpr#1-#2\relax,...,#1} {
            \draw[gray!60] (-0.1, \y) -- (0.1, \y);
            \node[font=\tiny, gray, anchor=east] at (-0.2, \y) {\y};
        }
    \end{scope}
}

% Draw zone boundaries for network segments
% Usage: \drawZoneBoundary{x}{y}{width}{height}{zone_name}{security_level}
% security_level: 'high', 'medium', 'low'
\newcommand{\drawZoneBoundary}[6]{
    \IfStrEq{#6}{high}{
        \def\zoneColor{green!60}
    }{
        \IfStrEq{#6}{medium}{
            \def\zoneColor{yellow!60}
        }{
            \def\zoneColor{red!60}
        }
    }
    \begin{scope}[on background layer]
        \draw[draw=\zoneColor, fill=\zoneColor!5, line width=2pt, rounded corners=5pt,
              double, double distance=2pt]
            (#1 - #3/2, #2 - #4/2) rectangle (#1 + #3/2, #2 + #4/2);
        \node[fill=white, draw=\zoneColor, rounded corners=2pt, font=\small\bfseries,
              anchor=north west]
            at (#1 - #3/2 + 0.2, #2 + #4/2 - 0.2) {#5};
        \node[fill=\zoneColor!20, font=\tiny, anchor=north east, rounded corners=1pt]
            at (#1 + #3/2 - 0.2, #2 + #4/2 - 0.2) {#6 trust};
    \end{scope}
}

% ============================================================================
% HIERARCHICAL LAYOUTS
% ============================================================================

% Tree layout for hierarchical networks
% Usage: \layoutTree{root_x}{root_y}{level_spacing}{sibling_spacing}{inverted}
% inverted: 'true' for root at bottom, 'false' for root at top
\newcommand{\layoutTree}[5]{
    \def\treeRootX{#1}
    \def\treeRootY{#2}
    \def\treeLevelSpacing{#3}
    \def\treeSiblingSpacing{#4}
    \def\treeInverted{#5}
}

% Calculate tree node position
% Usage: \calcTreePosition{level}{position}{total_siblings}{level_spacing}{sibling_spacing}{inverted}{result_x}{result_y}
\newcommand{\calcTreePosition}[8]{
    % Calculate x position (centered around 0)
    \pgfmathsetmacro{\totalWidth}{(#3 - 1) * #5}
    \pgfmathsetmacro{\startX}{-\totalWidth / 2}
    \pgfmathsetmacro{#7}{\startX + #2 * #5}
    % Calculate y position (depends on inverted flag)
    \IfStrEq{#6}{true}{
        \pgfmathsetmacro{#8}{#1 * #4}  % Inverted: positive y for deeper levels
    }{
        \pgfmathsetmacro{#8}{-#1 * #4}  % Normal: negative y for deeper levels
    }
}

% Calculate optimal sibling spacing for tree level
% Usage: \calcTreeSiblingSpacing{num_siblings}{parent_width}{result_macro}
\newcommand{\calcTreeSiblingSpacing}[3]{
    \pgfmathsetmacro{#3}{max(2, #2 / max(1, #1 - 1))}
}

% Binary tree position calculation
% Usage: \calcBinaryTreePosition{level}{is_left}{parent_x}{parent_y}{spacing}{result_x}{result_y}
% is_left: 0 for right child, 1 for left child
\newcommand{\calcBinaryTreePosition}[7]{
    \pgfmathsetmacro{#6}{#3 + (#5) * (1 - 2 * #2)}  % Left: -spacing, Right: +spacing
    \pgfmathsetmacro{#7}{#4 - \treeLevelSpacing}
}

% N-ary tree position calculation (generalized)
% Usage: \calcNaryTreePosition{parent_x}{parent_y}{child_index}{num_children}{spacing}{result_x}{result_y}
\newcommand{\calcNaryTreePosition}[7]{
    \pgfmathsetmacro{\totalWidth}{(#4 - 1) * #5}
    \pgfmathsetmacro{\offsetX}{-\totalWidth/2 + #3 * #5}
    \pgfmathsetmacro{#6}{#1 + \offsetX}
    \pgfmathsetmacro{#7}{#2 - \treeLevelSpacing}
}

% Automatic tree balancing (calculate center of subtree)
% Usage: \calcSubtreeCenter{leftmost_x}{rightmost_x}{result_macro}
\newcommand{\calcSubtreeCenter}[3]{
    \pgfmathsetmacro{#3}{(#1 + #2) / 2}
}

% Tree width calculation for balancing
% Usage: \calcTreeWidth{num_nodes}{branching_factor}{level}{min_spacing}{result_macro}
\newcommand{\calcTreeWidth}[5]{
    \pgfmathsetmacro{\nodesAtLevel}{min(#1, #2^#3)}
    \pgfmathsetmacro{#5}{\nodesAtLevel * #4}
}

% Unbalanced tree support (custom child positions)
% Usage: \calcUnbalancedTreePosition{parent_x}{parent_y}{child_positions_list}{child_index}{result_x}{result_y}
% Note: child_positions_list would be a list of relative x-offsets
\newcommand{\calcUnbalancedTreePosition}[6]{
    % Simplified version - uses uniform spacing
    \pgfmathsetmacro{#5}{#1 + (#4 - 1) * \treeSiblingSpacing - \treeSiblingSpacing}
    \pgfmathsetmacro{#6}{#2 - \treeLevelSpacing}
}

% Inverted tree (root at bottom)
% Usage: \drawInvertedTree{root_x}{root_y}{levels}{branching_factor}
\newcommand{\drawInvertedTree}[4]{
    \layoutTree{#1}{#2}{\treeLevelSpacing}{\treeSiblingSpacing}{true}
}

% ============================================================================
% ORGANIC/FORCE-DIRECTED LAYOUTS
% ============================================================================

% Force-directed layout using Fruchterman-Reingold algorithm
% This is a simplified implementation; for complex graphs, use external tools
% Usage: \layoutForceDirected{num_nodes}{num_iterations}{area_width}{area_height}
\newcommand{\layoutForceDirected}[4]{
    \def\numNodes{#1}
    \def\numIterations{#2}
    \def\areaWidth{#3}
    \def\areaHeight{#4}
    % Optimal distance between nodes
    \pgfmathsetmacro{\optimalDist}{sqrt(\areaWidth * \areaHeight / \numNodes)}
}

% Calculate repulsive force between nodes (Fruchterman-Reingold)
% Usage: \calcRepulsiveForce{x1}{y1}{x2}{y2}{k}{result_fx}{result_fy}
\newcommand{\calcRepulsiveForce}[7]{
    \pgfmathsetmacro{\dx}{#3 - #1}
    \pgfmathsetmacro{\dy}{#4 - #2}
    \pgfmathsetmacro{\dist}{max(0.1, sqrt(\dx * \dx + \dy * \dy))}
    \pgfmathsetmacro{\force}{(#5 * #5) / \dist}
    \pgfmathsetmacro{#6}{-(\dx / \dist) * \force}
    \pgfmathsetmacro{#7}{-(\dy / \dist) * \force}
}

% Calculate attractive force along edges (spring force)
% Usage: \calcAttractiveForce{x1}{y1}{x2}{y2}{k}{result_fx}{result_fy}
\newcommand{\calcAttractiveForce}[7]{
    \pgfmathsetmacro{\dx}{#3 - #1}
    \pgfmathsetmacro{\dy}{#4 - #2}
    \pgfmathsetmacro{\dist}{sqrt(\dx * \dx + \dy * \dy)}
    \pgfmathsetmacro{\force}{(\dist * \dist) / #5}
    \pgfmathsetmacro{#6}{(\dx / max(0.1, \dist)) * \force}
    \pgfmathsetmacro{#7}{(\dy / max(0.1, \dist)) * \force}
}

% Export node positions to external file for GraphViz/networkx processing
% Usage: \exportPositionsForExternal{filename}
\newcommand{\exportPositionsForExternal}[1]{
    \newwrite\posfile
    \immediate\openout\posfile=#1
    % Format: node_id,x,y
    % Note: Actual export requires iterating through nodes
    \immediate\closeout\posfile
}

% Import node positions from external tool
% Usage: \importPositionsFromExternal{filename}
\newcommand{\importPositionsFromExternal}[1]{
    % Read file with format: node_id,x,y
    % Parse and set coordinates
    % Requires pgfplotstable or similar
}

% Kamada-Kawai spring layout helper
% Usage: \calcKamadaKawaiForce{x1}{y1}{x2}{y2}{spring_constant}{ideal_length}{result_fx}{result_fy}
\newcommand{\calcKamadaKawaiForce}[8]{
    \pgfmathsetmacro{\dx}{#3 - #1}
    \pgfmathsetmacro{\dy}{#4 - #2}
    \pgfmathsetmacro{\dist}{sqrt(\dx * \dx + \dy * \dy)}
    \pgfmathsetmacro{\force}{#5 * (\dist - #6)}
    \pgfmathsetmacro{#7}{(\dx / max(0.1, \dist)) * \force}
    \pgfmathsetmacro{#8}{(\dy / max(0.1, \dist)) * \force}
}

% ============================================================================
% SUBNET AUTO-GROUPING
% ============================================================================

% Parse IP address octets
% Usage: \parseIPAddress{ip_address}{octet1}{octet2}{octet3}{octet4}
\newcommand{\parseIPAddress}[5]{
    \StrCut{#1}{.}{\octA}{\restA}
    \StrCut{\restA}{.}{\octB}{\restB}
    \StrCut{\restB}{.}{\octC}{\octD}
    \xdef#2{\octA}
    \xdef#3{\octB}
    \xdef#4{\octC}
    \xdef#5{\octD}
}

% Calculate subnet from IP and CIDR prefix
% Usage: \calcSubnetID{ip_address}{cidr_prefix}{result_subnet}
\newcommand{\calcSubnetID}[3]{
    \parseIPAddress{#1}{\octA}{\octB}{\octC}{\octD}
    \ifnum#2<9
        % /8 network
        \xdef#3{\octA.0.0.0/#2}
    \else\ifnum#2<17
        % /16 network
        \xdef#3{\octA.\octB.0.0/#2}
    \else\ifnum#2<25
        % /24 network
        \xdef#3{\octA.\octB.\octC.0/#2}
    \else
        % Smaller subnet
        \xdef#3{\octA.\octB.\octC.\octD/#2}
    \fi\fi\fi
}

% Determine trust level color based on subnet
% Usage: \getSubnetTrustColor{subnet_prefix}{result_color}
\newcommand{\getSubnetTrustColor}[2]{
    \StrBefore{#1}{.}[\firstOctet]
    % RFC 1918 private addresses: 10.x.x.x (high trust), 172.16-31.x.x (medium), 192.168.x.x (high)
    \IfStrEq{\firstOctet}{10}{\xdef#2{green!60}}{
        \IfStrEq{\firstOctet}{172}{\xdef#2{yellow!60}}{
            \IfStrEq{\firstOctet}{192}{\xdef#2{green!60}}{
                % Public IP - low trust
                \xdef#2{red!60}
            }
        }
    }
}

% Auto-group nodes by subnet
% Usage: \autoGroupSubnets{cidr_prefix}
% Example: \autoGroupSubnets{24} groups all nodes by /24 subnets
\newcommand{\autoGroupSubnets}[1]{
    \def\cidrPrefix{#1}
    % This would iterate through all defined nodes
    % For each node with an IP address:
    %   1. Calculate subnet ID
    %   2. Group nodes with same subnet ID
    %   3. Draw subnet boundary box
    %   4. Color-code by trust level
}

% Draw subnet boundary with auto-coloring
% Usage: \drawAutoSubnet{subnet_id}{nodes}{label}
\newcommand{\drawAutoSubnet}[3]{
    \getSubnetTrustColor{#1}{\subnetColor}
    \begin{scope}[on background layer]
        \node[
            fit=#2,
            draw=\subnetColor,
            fill=\subnetColor!5,
            rounded corners=5pt,
            line width=1.5pt,
            inner sep=15pt,
            label={[fill=white, draw=\subnetColor, rounded corners=2pt,
                   font=\small\bfseries\sffamily]above:{#3 (#1)}}
        ] (subnet-#1) {};
    \end{scope}
}

% Handle nested/overlapping subnets (VLAN support)
% Usage: \drawNestedSubnet{outer_subnet}{inner_subnet}{nodes}{label}
\newcommand{\drawNestedSubnet}[4]{
    % Draw outer subnet first
    \getSubnetTrustColor{#1}{\outerColor}
    \getSubnetTrustColor{#2}{\innerColor}
    \begin{scope}[on background layer]
        % Inner subnet with pattern to show nesting
        \node[
            fit=#3,
            draw=\innerColor,
            fill=\innerColor!10,
            rounded corners=3pt,
            line width=1pt,
            inner sep=10pt,
            pattern=north east lines,
            pattern color=\innerColor!20,
            label={[fill=white, draw=\innerColor, rounded corners=2pt,
                   font=\tiny\bfseries\sffamily]above:{#4}}
        ] (subnet-#2) {};
    \end{scope}
}

% Check if IP is in private range (RFC 1918)
% Usage: \isPrivateIP{ip_address}{result_macro}
% Returns 1 if private, 0 if public
\newcommand{\isPrivateIP}[2]{
    \parseIPAddress{#1}{\octA}{\octB}{\octC}{\octD}
    \pgfmathsetmacro{#2}{
        ifthenelse(\octA == 10, 1,
        ifthenelse(and(\octA == 172, \octB >= 16, \octB <= 31), 1,
        ifthenelse(and(\octA == 192, \octB == 168), 1, 0)))
    }
}

% ============================================================================
% LAYOUT HELPERS AND UTILITIES
% ============================================================================

% Calculate midpoint between two nodes
% Usage: \nodeMidpoint{node1}{node2}{resultname}
\newcommand{\nodeMidpoint}[3]{
    \coordinate (#3) at ($(#1)!0.5!(#2)$);
}

% Position node relative to another
% Usage: \positionRelative{newnode}{refnode}{distance}{angle}{style}
\newcommand{\positionRelative}[5]{
    \node[#5] (#1) at ($(#2)+({#4}:{#3})$) {};
}

% ============================================================================
% COLLISION DETECTION AND AVOIDANCE
% ============================================================================

% Minimum safe spacing between nodes (configurable)
\newlength{\minNodeSpacing}
\setlength{\minNodeSpacing}{3cm}

% Check if two nodes overlap
% Usage: \checkNodeCollision{x1}{y1}{x2}{y2}{radius1}{radius2}{result_macro}
% Returns 1 if collision detected, 0 otherwise
\newcommand{\checkNodeCollision}[7]{
    \pgfmathsetmacro{\dx}{#3 - #1}
    \pgfmathsetmacro{\dy}{#4 - #2}
    \pgfmathsetmacro{\dist}{sqrt(\dx * \dx + \dy * \dy)}
    \pgfmathsetmacro{\minDist}{#5 + #6 + \minNodeSpacing / 1cm}
    \pgfmathsetmacro{#7}{ifthenelse(\dist < \minDist, 1, 0)}
}

% Adjust node position to avoid collision
% Usage: \avoidCollision{x}{y}{target_x}{target_y}{result_x}{result_y}
\newcommand{\avoidCollision}[6]{
    \pgfmathsetmacro{\dx}{#3 - #1}
    \pgfmathsetmacro{\dy}{#4 - #2}
    \pgfmathsetmacro{\angle}{atan2(\dy, \dx)}
    \pgfmathsetmacro{\offsetDist}{\minNodeSpacing / 1cm}
    \pgfmathsetmacro{#5}{#1 + cos(\angle) * \offsetDist}
    \pgfmathsetmacro{#6}{#2 + sin(\angle) * \offsetDist}
}

% Snap position to grid
% Usage: \snapToGrid{x}{y}{grid_size}{result_x}{result_y}
\newcommand{\snapToGrid}[5]{
    \pgfmathsetmacro{#4}{round(#1 / #3) * #3}
    \pgfmathsetmacro{#5}{round(#2 / #3) * #3}
}

% Magnetic alignment to nearby nodes (within threshold)
% Usage: \magneticAlign{x}{y}{ref_x}{ref_y}{threshold}{result_x}{result_y}
\newcommand{\magneticAlign}[7]{
    \pgfmathsetmacro{\deltaX}{abs(#1 - #3)}
    \pgfmathsetmacro{\deltaY}{abs(#2 - #4)}
    \pgfmathsetmacro{#6}{ifthenelse(\deltaX < #5, #3, #1)}
    \pgfmathsetmacro{#7}{ifthenelse(\deltaY < #5, #4, #2)}
}

% Distribute nodes evenly in a rectangular area
% Usage: \distributeNodesInArea{num_nodes}{area_width}{area_height}{start_x}{start_y}
\newcommand{\distributeNodesInArea}[5]{
    \pgfmathsetmacro{\cols}{ceil(sqrt(#1))}
    \pgfmathsetmacro{\rows}{ceil(#1 / \cols)}
    \pgfmathsetmacro{\spacingX}{#2 / (\cols + 1)}
    \pgfmathsetmacro{\spacingY}{#3 / (\rows + 1)}
}

% ============================================================================
% MULTI-PAGE LAYOUT SUPPORT
% ============================================================================

% Multi-page layout for very large networks
% Usage: \layoutMultiPage{num_nodes}{nodes_per_page}{overlap_margin}
\newcommand{\layoutMultiPage}[3]{
    \def\totalNodes{#1}
    \def\nodesPerPage{#2}
    \def\overlapMargin{#3}
    \pgfmathsetmacro{\numPages}{ceil(#1 / #2)}
}

% Calculate page number for a node
% Usage: \calcNodePage{node_index}{nodes_per_page}{result_macro}
\newcommand{\calcNodePage}[3]{
    \pgfmathsetmacro{#3}{ceil(#1 / #2)}
}

% Draw cross-reference marker to another page
% Usage: \drawPageReference{x}{y}{target_page}{label}{direction}
% direction: 'to' or 'from'
\newcommand{\drawPageReference}[5]{
    \IfStrEq{#5}{to}{
        \node[draw=orange!80, fill=orange!20, circle, line width=1pt,
              font=\tiny\bfseries, minimum size=0.6cm] at (#1, #2)
              {\rotatebox{45}{$\rightarrow$} P#3};
    }{
        \node[draw=blue!80, fill=blue!20, circle, line width=1pt,
              font=\tiny\bfseries, minimum size=0.6cm] at (#1, #2)
              {\rotatebox{225}{$\leftarrow$} P#3};
    }
    \node[font=\tiny, fill=white, rounded corners=1pt, anchor=north]
        at (#1, #2 - 0.4) {#4};
}

% Draw overview page with thumbnail navigation
% Usage: \drawOverviewPage{total_pages}{current_page}
\newcommand{\drawOverviewPage}[2]{
    \begin{scope}[shift={(12, -2)}]
        \node[font=\small\bfseries, anchor=north] at (0, 0.5) {Page Map};
        \draw[draw=gray!60, fill=gray!10, rounded corners=2pt]
            (-1.2, -0.2) rectangle (1.2, -#1*0.5 - 0.2);
        \foreach \p in {1,...,#1} {
            \pgfmathsetmacro{\pageY}{-\p * 0.4}
            \IfStrEq{\p}{#2}{
                \draw[fill=green!40, draw=green!80, line width=1pt, rounded corners=1pt]
                    (-1, \pageY) rectangle (1, \pageY + 0.3);
                \node[font=\tiny\bfseries] at (0, \pageY + 0.15) {Page \p (current)};
            }{
                \draw[fill=white, draw=gray!60, rounded corners=1pt]
                    (-1, \pageY) rectangle (1, \pageY + 0.3);
                \node[font=\tiny] at (0, \pageY + 0.15) {Page \p};
            }
        }
    \end{scope}
}

% Create detail page for subnet
% Usage: \createDetailPage{page_num}{subnet_id}{zoom_level}
\newcommand{\createDetailPage}[3]{
    \def\currentPage{#1}
    \def\focusSubnet{#2}
    \def\zoomLevel{#3}
}

% Automatic page breaking based on node density
% Usage: \autoPageBreak{node_count}{max_density}{area_width}{area_height}{result_pages}
\newcommand{\autoPageBreak}[5]{
    \pgfmathsetmacro{\areaSize}{#3 * #4}
    \pgfmathsetmacro{\maxNodesPerPage}{#2 * \areaSize}
    \pgfmathsetmacro{#5}{ceil(#1 / \maxNodesPerPage)}
}

% Maintain consistent positioning across pages
% Usage: \createGlobalCoordinate{name}{x}{y}
% Stores coordinate that persists across pages
\newcommand{\createGlobalCoordinate}[3]{
    \expandafter\xdef\csname globalX#1\endcsname{#2}
    \expandafter\xdef\csname globalY#1\endcsname{#3}
}

% Retrieve global coordinate
% Usage: \useGlobalCoordinate{name}{result_x}{result_y}
\newcommand{\useGlobalCoordinate}[3]{
    \pgfmathsetmacro{#2}{\csname globalX#1\endcsname}
    \pgfmathsetmacro{#3}{\csname globalY#1\endcsname}
}

% Draw page header with navigation
% Usage: \drawPageHeader{page_num}{total_pages}{title}
\newcommand{\drawPageHeader}[3]{
    \begin{scope}[shift={(0, 15)}]
        \node[font=\Large\bfseries, anchor=north] at (0, 0) {#3};
        \node[font=\small, anchor=north east, gray] at (10, -0.5)
            {Page #1 of #2};
        % Previous/Next indicators
        \ifnum#1>1
            \node[draw=blue!60, fill=blue!10, rounded corners=2pt,
                  font=\tiny, anchor=north west] at (-10, -0.5)
                {$\leftarrow$ Previous: Page \the\numexpr#1-1\relax};
        \fi
        \ifnum#1<#2
            \node[draw=blue!60, fill=blue!10, rounded corners=2pt,
                  font=\tiny, anchor=north east] at (10, -0.5)
                {Next: Page \the\numexpr#1+1\relax\  $\rightarrow$};
        \fi
    \end{scope}
}

% ============================================================================
% DYNAMIC LAYOUT ADJUSTMENT
% ============================================================================

% Calculate diagram complexity score
% Usage: \calcComplexityScore{num_nodes}{num_connections}{result_macro}
% Returns a score from 0-100 (0=simple, 100=very complex)
\newcommand{\calcComplexityScore}[3]{
    \pgfmathsetmacro{\nodeScore}{min(50, #1 / 2)}
    \pgfmathsetmacro{\connectionScore}{min(50, #2 / 4)}
    \pgfmathsetmacro{#3}{\nodeScore + \connectionScore}
}

% Auto-adjust spacing for readability based on complexity
% Usage: \autoAdjustSpacing{complexity_score}{base_spacing}{result_spacing}
\newcommand{\autoAdjustSpacing}[3]{
    \pgfmathsetmacro{\scaleFactor}{1 + (#1 / 100) * 0.5}
    \pgfmathsetmacro{#3}{#2 * \scaleFactor}
}

% Adjust layout based on diagram density
% Usage: \optimizeLayout{num_nodes}{area_width}{area_height}
\newcommand{\optimizeLayout}[3]{
    \pgfmathsetmacro{\density}{#1 / (#2 * #3)}
    \pgfmathsetmacro{\optimalDensity}{0.05}  % nodes per square cm
    \pgfmathsetmacro{\scalingFactor}{sqrt(\density / \optimalDensity)}
}

% Identify overlapping elements
% Usage: \detectOverlaps{node_list}{threshold}{result_count}
\newcommand{\detectOverlaps}[3]{
    % This would iterate through all node pairs
    % For now, returns a placeholder
    \def#3{0}
}

% Optimize for print vs screen display
% Usage: \setDisplayMode{mode}
% mode: 'print' or 'screen'
\newcommand{\setDisplayMode}[1]{
    \IfStrEq{#1}{print}{
        % Increase line widths and font sizes for print
        \def\displayScale{1.2}
        \def\minLineWidth{0.8pt}
        \def\baseFontSize{\normalsize}
    }{
        % Optimize for screen viewing
        \def\displayScale{1.0}
        \def\minLineWidth{0.5pt}
        \def\baseFontSize{\small}
    }
}

% Responsive layout for different output sizes
% Usage: \setOutputSize{size}
% size: 'a4', 'a3', 'a2', 'a1', 'letter', 'screen'
\newcommand{\setOutputSize}[1]{
    \IfStrEq{#1}{a4}{
        \def\pageWidth{21}
        \def\pageHeight{29.7}
        \def\layoutScale{1.0}
    }{}
    \IfStrEq{#1}{a3}{
        \def\pageWidth{29.7}
        \def\pageHeight{42}
        \def\layoutScale{1.4}
    }{}
    \IfStrEq{#1}{a2}{
        \def\pageWidth{42}
        \def\pageHeight{59.4}
        \def\layoutScale{2.0}
    }{}
    \IfStrEq{#1}{letter}{
        \def\pageWidth{21.6}
        \def\pageHeight{27.9}
        \def\layoutScale{1.0}
    }{}
    \IfStrEq{#1}{screen}{
        \def\pageWidth{16}
        \def\pageHeight{9}
        \def\layoutScale{0.8}
    }{}
}

% ============================================================================
% ZOOM AND LEVEL OF DETAIL
% ============================================================================

% Set zoom level
% Usage: \setZoomLevel{level}
% level: 1.0 = normal, 2.0 = 2x zoom, 0.5 = zoom out
\newcommand{\setZoomLevel}[1]{
    \def\currentZoom{#1}
    \pgfmathsetmacro{\inverseZoom}{1 / #1}
}

% Calculate level of detail visibility
% Usage: \shouldShowDetail{zoom_level}{detail_threshold}{result_macro}
% Returns 1 if detail should be shown, 0 otherwise
\newcommand{\shouldShowDetail}[3]{
    \pgfmathsetmacro{#3}{ifthenelse(#1 >= #2, 1, 0)}
}

% Overview mode (hide detailed labels, simplify connections)
% Usage: \setOverviewMode{enabled}
% enabled: 'true' or 'false'
\newcommand{\setOverviewMode}[1]{
    \IfStrEq{#1}{true}{
        \def\showDetailedLabels{false}
        \def\showAllPorts{false}
        \def\connectionStyle{simplified}
    }{
        \def\showDetailedLabels{true}
        \def\showAllPorts{true}
        \def\connectionStyle{detailed}
    }
}

% Detail mode (show all information)
% Usage: \setDetailMode{zoom_level}
\newcommand{\setDetailMode}[1]{
    \setZoomLevel{#1}
    \setOverviewMode{false}
}

% Adaptive detail rendering based on zoom
% Usage: \renderAdaptiveDetail{zoom_level}{element_type}
\newcommand{\renderAdaptiveDetail}[2]{
    \pgfmathsetmacro{\showBasic}{ifthenelse(#1 >= 0.5, 1, 0)}
    \pgfmathsetmacro{\showMedium}{ifthenelse(#1 >= 1.0, 1, 0)}
    \pgfmathsetmacro{\showFull}{ifthenelse(#1 >= 1.5, 1, 0)}
}

% ============================================================================
% LAYOUT TEMPLATES FOR COMMON SCENARIOS
% ============================================================================

% Template: 3-tier web application (standard LAMP/MEAN stack)
% Usage: \template3TierWeb{base_x}{base_y}{spacing}
\newcommand{\templateThreeTierWeb}[3]{
    \def\webTierY{#2 + 2 * #3}
    \def\appTierY{#2 + #3}
    \def\dataTierY{#2}
}

% Template: DMZ with dual firewalls
% Usage: \templateDMZ{center_x}{center_y}{width}
\newcommand{\templateDMZ}[3]{
    \def\dmzCenterX{#1}
    \def\dmzCenterY{#2}
    \def\dmzWidth{#3}
}

% Template: High availability pair
% Usage: \templateHAPair{center_x}{center_y}{spacing}{orientation}
% orientation: 'horizontal' or 'vertical'
\newcommand{\templateHAPair}[4]{
    \IfStrEq{#4}{horizontal}{
        \pgfmathsetmacro{\haX1}{#1 - #3/2}
        \pgfmathsetmacro{\haX2}{#1 + #3/2}
        \pgfmathsetmacro{\haY1}{#2}
        \pgfmathsetmacro{\haY2}{#2}
    }{
        \pgfmathsetmacro{\haX1}{#1}
        \pgfmathsetmacro{\haX2}{#1}
        \pgfmathsetmacro{\haY1}{#2 + #3/2}
        \pgfmathsetmacro{\haY2}{#2 - #3/2}
    }
}

% Template: Load balancer cluster
% Usage: \templateLoadBalancerCluster{center_x}{center_y}{lb_count}{backend_count}
\newcommand{\templateLoadBalancerCluster}[4]{
    \def\lbCenterX{#1}
    \def\lbCenterY{#2}
    \def\lbCount{#3}
    \def\backendCount{#4}
}

% ============================================================================
% ADVANCED LAYOUT HELPER UTILITIES
% ============================================================================

% Calculate bounding box for a set of nodes
% Usage: \calcBoundingBox{node_list}{margin}{result_minx}{result_miny}{result_maxx}{result_maxy}
\newcommand{\calcBoundingBox}[6]{
    % This is a simplified version - actual implementation would iterate through nodes
    \def#3{-10}
    \def#4{-10}
    \def#5{10}
    \def#6{10}
}

% Distribute nodes along a path
% Usage: \distributeAlongPath{num_nodes}{path_start_x}{path_start_y}{path_end_x}{path_end_y}
\newcommand{\distributeAlongPath}[5]{
    \pgfmathsetmacro{\pathDeltaX}{(#4 - #2) / (#1 + 1)}
    \pgfmathsetmacro{\pathDeltaY}{(#5 - #3) / (#1 + 1)}
}

% Create node position along bezier curve
% Usage: \positionOnBezier{p0x}{p0y}{p1x}{p1y}{p2x}{p2y}{p3x}{p3y}{t}{result_x}{result_y}
% t: position along curve (0.0 to 1.0)
\newcommand{\positionOnBezier}[11]{
    \pgfmathsetmacro{\oneMinusT}{1 - #9}
    \pgfmathsetmacro{\t2}{#9 * #9}
    \pgfmathsetmacro{\t3}{#9 * #9 * #9}
    \pgfmathsetmacro{\oneMinusT2}{\oneMinusT * \oneMinusT}
    \pgfmathsetmacro{\oneMinusT3}{\oneMinusT * \oneMinusT * \oneMinusT}

    \pgfmathsetmacro{#10}{
        \oneMinusT3 * #1 +
        3 * \oneMinusT2 * #9 * #3 +
        3 * \oneMinusT * \t2 * #5 +
        \t3 * #7
    }
    \pgfmathsetmacro{#11}{
        \oneMinusT3 * #2 +
        3 * \oneMinusT2 * #9 * #4 +
        3 * \oneMinusT * \t2 * #6 +
        \t3 * #8
    }
}

% Mirror position across axis
% Usage: \mirrorPosition{x}{y}{axis}{result_x}{result_y}
% axis: 'x', 'y', or 'both'
\newcommand{\mirrorPosition}[5]{
    \IfStrEq{#3}{x}{
        \pgfmathsetmacro{#4}{#1}
        \pgfmathsetmacro{#5}{-#2}
    }{}
    \IfStrEq{#3}{y}{
        \pgfmathsetmacro{#4}{-#1}
        \pgfmathsetmacro{#5}{#2}
    }{}
    \IfStrEq{#3}{both}{
        \pgfmathsetmacro{#4}{-#1}
        \pgfmathsetmacro{#5}{-#2}
    }{}
}

% Rotate position around origin
% Usage: \rotatePosition{x}{y}{angle_degrees}{result_x}{result_y}
\newcommand{\rotatePosition}[5]{
    \pgfmathsetmacro{#4}{#1 * cos(#3) - #2 * sin(#3)}
    \pgfmathsetmacro{#5}{#1 * sin(#3) + #2 * cos(#3)}
}

% Scale position from origin
% Usage: \scalePosition{x}{y}{scale_factor}{result_x}{result_y}
\newcommand{\scalePosition}[5]{
    \pgfmathsetmacro{#4}{#1 * #3}
    \pgfmathsetmacro{#5}{#2 * #3}
}

% Calculate distance between two points
% Usage: \calcDistance{x1}{y1}{x2}{y2}{result_macro}
\newcommand{\calcDistance}[5]{
    \pgfmathsetmacro{\dx}{#3 - #1}
    \pgfmathsetmacro{\dy}{#4 - #2}
    \pgfmathsetmacro{#5}{sqrt(\dx * \dx + \dy * \dy)}
}

% Find nearest grid point
% Usage: \findNearestGridPoint{x}{y}{grid_spacing}{result_x}{result_y}
\newcommand{\findNearestGridPoint}[5]{
    \pgfmathsetmacro{#4}{round(#1 / #3) * #3}
    \pgfmathsetmacro{#5}{round(#2 / #3) * #3}
}

% Interpolate between two positions
% Usage: \interpolatePosition{x1}{y1}{x2}{y2}{ratio}{result_x}{result_y}
% ratio: 0.0 = pos1, 1.0 = pos2, 0.5 = midpoint
\newcommand{\interpolatePosition}[7]{
    \pgfmathsetmacro{#6}{#1 + (#3 - #1) * #5}
    \pgfmathsetmacro{#7}{#2 + (#4 - #2) * #5}
}

% Create regular polygon vertices
% Usage: \calcPolygonVertex{center_x}{center_y}{radius}{sides}{vertex_index}{result_x}{result_y}
\newcommand{\calcPolygonVertex}[7]{
    \pgfmathsetmacro{\angle}{360 / #4 * #5}
    \pgfmathsetmacro{#6}{#1 + #3 * cos(\angle)}
    \pgfmathsetmacro{#7}{#2 + #3 * sin(\angle)}
}

% Align nodes in a row with equal spacing
% Usage: \alignNodesHorizontal{start_x}{y}{num_nodes}{total_width}
\newcommand{\alignNodesHorizontal}[4]{
    \pgfmathsetmacro{\nodeSpacingH}{#4 / (#3 - 1)}
}

% Align nodes in a column with equal spacing
% Usage: \alignNodesVertical{x}{start_y}{num_nodes}{total_height}
\newcommand{\alignNodesVertical}[4]{
    \pgfmathsetmacro{\nodeSpacingV}{#4 / (#3 - 1)}
}

% Create spiral layout position
% Usage: \calcSpiralPosition{center_x}{center_y}{angle}{radius_factor}{result_x}{result_y}
\newcommand{\calcSpiralPosition}[6]{
    \pgfmathsetmacro{\spiralRadius}{#4 * #3 / 360}
    \pgfmathsetmacro{#5}{#1 + \spiralRadius * cos(#3)}
    \pgfmathsetmacro{#6}{#2 + \spiralRadius * sin(#3)}
}

% ============================================================================
% DEBUGGING AND VALIDATION TOOLS
% ============================================================================

% Draw debug grid with coordinates
% Usage: \enableDebugMode{grid_spacing}{show_coordinates}
\newcommand{\enableDebugMode}[2]{
    \begin{scope}[on background layer]
        % Draw grid
        \draw[step=#1cm, gray!30, very thin] (-15,-15) grid (15,15);

        % Draw coordinate labels if enabled
        \IfStrEq{#2}{true}{
            \foreach \x in {-15,-10,...,15} {
                \foreach \y in {-15,-10,...,15} {
                    \node[font=\tiny, gray, fill=white, inner sep=1pt] at (\x, \y) {(\x,\y)};
                }
            }
        }{}

        % Draw axes
        \draw[thick, red!50, ->] (-15, 0) -- (15, 0) node[right] {x};
        \draw[thick, blue!50, ->] (0, -15) -- (0, 15) node[above] {y};

        % Origin marker
        \fill[green] (0,0) circle (0.1cm);
        \node[font=\small, green, below right] at (0,0) {(0,0)};
    \end{scope}
}

% Validate node position is within bounds
% Usage: \validatePosition{x}{y}{max_x}{max_y}{result_macro}
% Returns 1 if valid, 0 if out of bounds
\newcommand{\validatePosition}[5]{
    \pgfmathsetmacro{#5}{
        ifthenelse(and(abs(#1) <= #3, abs(#2) <= #4), 1, 0)
    }
}

% Draw bounding box for debugging
% Usage: \drawDebugBoundingBox{x}{y}{width}{height}{label}
\newcommand{\drawDebugBoundingBox}[5]{
    \draw[dashed, red!60, line width=0.5pt]
        (#1 - #3/2, #2 - #4/2) rectangle (#1 + #3/2, #2 + #4/2);
    \node[font=\tiny, red, fill=white, anchor=south west]
        at (#1 - #3/2, #2 + #4/2) {#5};
}

% Show node spacing measurements
% Usage: \showSpacingMeasurement{x1}{y1}{x2}{y2}
\newcommand{\showSpacingMeasurement}[4]{
    \calcDistance{#1}{#2}{#3}{#4}{\spacing}
    \draw[blue!40, thin, <->] (#1, #2) -- (#3, #4)
        node[midway, fill=white, font=\tiny] {\pgfmathprintnumber[precision=2]{\spacing}cm};
}

% Performance counter for node count
\newcounter{nodecount}
\newcounter{connectioncount}

% Increment counters (call when creating nodes/connections)
\newcommand{\incrementNodeCount}{\stepcounter{nodecount}}
\newcommand{\incrementConnectionCount}{\stepcounter{connectioncount}}

% Display performance metrics
% Usage: \showPerformanceMetrics{x}{y}
\newcommand{\showPerformanceMetrics}[2]{
    \calcComplexityScore{\value{nodecount}}{\value{connectioncount}}{\complexity}
    \node[fill=yellow!20, draw=orange!60, rounded corners=3pt, font=\tiny, anchor=north west]
        at (#1, #2) {
        \textbf{Performance Metrics}\\
        Nodes: \arabic{nodecount}\\
        Connections: \arabic{connectioncount}\\
        Complexity: \pgfmathprintnumber[precision=1]{\complexity}/100
    };
}

% Validate IP address format
% Usage: \validateIPAddress{ip_address}{result_macro}
% Returns 1 if valid IPv4, 0 otherwise
\newcommand{\validateIPAddress}[2]{
    % Simple validation - checks for 3 dots
    \StrCount{#1}{.}[\dotcount]
    \pgfmathsetmacro{#2}{ifthenelse(\dotcount == 3, 1, 0)}
}

% Check if layout is within recommended density
% Usage: \checkLayoutDensity{num_nodes}{area_width}{area_height}{result_macro}
% Returns 1 if density is good, 0 if too dense
\newcommand{\checkLayoutDensity}[4]{
    \pgfmathsetmacro{\density}{#1 / (#2 * #3)}
    \pgfmathsetmacro{#4}{ifthenelse(\density < 0.1, 1, 0)}
}

% ============================================================================
% POSITIONING PRESETS AND PATTERNS
% ============================================================================

% Preset: Pentagon layout
% Usage: \positionPentagon{center_x}{center_y}{radius}{rotation}{node_prefix}
\newcommand{\positionPentagon}[5]{
    \foreach \i in {0,...,4} {
        \calcPolygonVertex{#1}{#2}{#3}{5}{\i}{\vx}{\vy}
        \rotatePosition{\vx - #1}{\vy - #2}{#4}{\rx}{\ry}
        \coordinate (#5\i) at (#1 + \rx, #2 + \ry);
    }
}

% Preset: Hexagon layout
% Usage: \positionHexagon{center_x}{center_y}{radius}{rotation}{node_prefix}
\newcommand{\positionHexagon}[5]{
    \foreach \i in {0,...,5} {
        \calcPolygonVertex{#1}{#2}{#3}{6}{\i}{\vx}{\vy}
        \rotatePosition{\vx - #1}{\vy - #2}{#4}{\rx}{\ry}
        \coordinate (#5\i) at (#1 + \rx, #2 + \ry);
    }
}

% Preset: Star layout (alternating radii)
% Usage: \positionStar{center_x}{center_y}{inner_radius}{outer_radius}{points}{node_prefix}
\newcommand{\positionStar}[6]{
    \pgfmathsetmacro{\totalPoints}{#5 * 2}
    \foreach \i in {0,...,\the\numexpr\totalPoints-1\relax} {
        \pgfmathsetmacro{\isOuter}{int(mod(\i, 2))}
        \pgfmathsetmacro{\radius}{\isOuter ? #4 : #3}
        \calcPolygonVertex{#1}{#2}{\radius}{\totalPoints}{\i}{\vx}{\vy}
        \coordinate (#6\i) at (\vx, \vy);
    }
}

% Preset: Double ring layout
% Usage: \positionDoubleRing{center_x}{center_y}{inner_radius}{outer_radius}{inner_count}{outer_count}{prefix}
\newcommand{\positionDoubleRing}[7]{
    % Inner ring
    \foreach \i in {0,...,\the\numexpr#5-1\relax} {
        \calcCircularAngle{\i}{#5}{0}{\angle}
        \positionOnCircle{#1}{#2}{#3}{\angle}{#7inner\i}
    }
    % Outer ring
    \foreach \i in {0,...,\the\numexpr#6-1\relax} {
        \calcCircularAngle{\i}{#6}{0}{\angle}
        \positionOnCircle{#1}{#2}{#4}{\angle}{#7outer\i}
    }
}

% Preset: Diagonal line layout
% Usage: \positionDiagonalLine{start_x}{start_y}{end_x}{end_y}{num_nodes}{prefix}
\newcommand{\positionDiagonalLine}[6]{
    \foreach \i in {0,...,\the\numexpr#5-1\relax} {
        \pgfmathsetmacro{\ratio}{\i / (#5 - 1)}
        \interpolatePosition{#1}{#2}{#3}{#4}{\ratio}{\px}{\py}
        \coordinate (#6\i) at (\px, \py);
    }
}

% Preset: L-shape layout
% Usage: \positionLShape{corner_x}{corner_y}{h_length}{v_length}{h_count}{v_count}{prefix}
\newcommand{\positionLShape}[7]{
    % Horizontal arm
    \foreach \i in {0,...,\the\numexpr#5-1\relax} {
        \pgfmathsetmacro{\xpos}{#1 + \i * #3 / (#5 - 1)}
        \coordinate (#7h\i) at (\xpos, #2);
    }
    % Vertical arm (excluding corner to avoid duplication)
    \foreach \i in {1,...,\the\numexpr#6-1\relax} {
        \pgfmathsetmacro{\ypos}{#2 + \i * #4 / (#6 - 1)}
        \coordinate (#7v\i) at (#1, \ypos);
    }
}

% Preset: Wave pattern
% Usage: \positionWave{start_x}{y}{length}{amplitude}{frequency}{num_nodes}{prefix}
\newcommand{\positionWave}[7]{
    \foreach \i in {0,...,\the\numexpr#6-1\relax} {
        \pgfmathsetmacro{\xpos}{#1 + \i * #3 / (#6 - 1)}
        \pgfmathsetmacro{\phase}{\i * 360 * #5 / (#6 - 1)}
        \pgfmathsetmacro{\ypos}{#2 + #4 * sin(\phase)}
        \coordinate (#7\i) at (\xpos, \ypos);
    }
}

% ============================================================================
% LAYOUT QUALITY SCORING
% ============================================================================

% Calculate layout symmetry score
% Usage: \calcSymmetryScore{node_positions}{result_macro}
% Returns score 0-100 (100 = perfect symmetry)
\newcommand{\calcSymmetryScore}[2]{
    % Simplified - would need actual node position analysis
    \def#2{75}
}

% Calculate layout balance score
% Usage: \calcBalanceScore{node_positions}{result_macro}
% Returns score 0-100 (100 = perfectly balanced)
\newcommand{\calcBalanceScore}[2]{
    % Simplified - would need actual node position analysis
    \def#2{80}
}

% Calculate readability score
% Usage: \calcReadabilityScore{num_nodes}{num_connections}{area}{result_macro}
\newcommand{\calcReadabilityScore}[4]{
    \pgfmathsetmacro{\density}{#1 / #3}
    \pgfmathsetmacro{\connectivity}{#2 / max(1, #1)}
    \pgfmathsetmacro{#4}{max(0, 100 - \density * 50 - \connectivity * 10)}
}

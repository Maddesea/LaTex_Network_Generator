% network_layout.tex - Intelligent network layout and positioning
% This module handles automatic and manual layout algorithms

% ============================================================================
% LAYOUT PARAMETERS
% ============================================================================

\newlength{\nodeSpacing}
\setlength{\nodeSpacing}{4cm}

\newlength{\layerSpacing}
\setlength{\layerSpacing}{6cm}

\newlength{\subnetSpacing}
\setlength{\subnetSpacing}{8cm}

% TODO: Adaptive spacing
% - Calculate optimal spacing based on node count
% - Adjust for node size variations
% - Implement responsive spacing for different page sizes
% - Add padding/margin controls

% ============================================================================
% SUBNET/ZONE VISUALIZATION
% ============================================================================

% Draw a subnet boundary box
% Usage: \drawSubnet{name}{color}{nodes}{label}
\newcommand{\drawSubnet}[4]{
    \begin{scope}[on background layer]
        \node[
            fit=#3,
            draw=#2!60,
            fill=#2!5,
            rounded corners=5pt,
            line width=1.5pt,
            inner sep=15pt,
            label={[fill=white, draw=#2!60, rounded corners=2pt, 
                   font=\small\bfseries\sffamily]above:#4}
        ] (subnet-#1) {};
    \end{scope}
}

% Draw a security zone
% Usage: \drawSecurityZone{name}{color}{nodes}{label}{trustLevel}
\newcommand{\drawSecurityZone}[5]{
    \begin{scope}[on background layer]
        \node[
            fit=#3,
            draw=#2!70,
            fill=#2!8,
            rounded corners=8pt,
            line width=2pt,
            inner sep=20pt,
            double,
            double distance=1pt,
            label={[fill=white, draw=#2!70, rounded corners=2pt, 
                   font=\small\bfseries\sffamily, anchor=north west]
                   north west:{\textcolor{#2!90}{#4} \tiny(Trust: #5)}}
        ] (zone-#1) {};
    \end{scope}
}

% TODO: Advanced zone rendering
% - DMZ (Demilitarized Zone) specific styling
% - VLANs with distinct visual patterns
% - Trust boundary indicators with graduated shading
% - Network segment overlays
% - Geographical region grouping

% ============================================================================
% SUBNET-BASED AUTO-GROUPING
% ============================================================================

% Extract /24 subnet from IPv4 address
% Usage: \extractSubnet24{ip_address}
% Returns: sets \subnetid (e.g., "192.168.1" from "192.168.1.10")
\newcommand{\extractSubnet24}[1]{
    \StrBefore{#1}{.}[\octeta]
    \StrBehind{#1}{.}[\tempb]
    \StrBefore{\tempb}{.}[\octetb]
    \StrBehind{\tempb}{.}[\tempc]
    \StrBefore{\tempc}{.}[\octetc]
    \edef\subnetid{\octeta.\octetb.\octetc}
}

% Extract /16 subnet from IPv4 address
% Usage: \extractSubnet16{ip_address}
% Returns: sets \subnet16id (e.g., "192.168" from "192.168.1.10")
\newcommand{\extractSubnet16}[1]{
    \StrBefore{#1}{.}[\octeta]
    \StrBehind{#1}{.}[\tempb]
    \StrBefore{\tempb}{.}[\octetb]
    \edef\subnet16id{\octeta.\octetb}
}

% Register node in subnet group
% Usage: \addNodeToSubnet{node_id}{ip_address}{subnet_mask}
\newcommand{\addNodeToSubnet}[3]{
    \ifthenelse{\equal{#3}{24}}{
        \extractSubnet24{#2}
        \pgfkeys{/subnets/\subnetid/nodes/.append={#1,}}
    }{
    \ifthenelse{\equal{#3}{16}}{
        \extractSubnet16{#2}
        \pgfkeys{/subnets/\subnet16id/nodes/.append={#1,}}
    }{
        % Default to /24
        \extractSubnet24{#2}
        \pgfkeys{/subnets/\subnetid/nodes/.append={#1,}}
    }}
}

% Auto-detect and group all nodes by subnet
% Usage: \autoGroupSubnets
% This would iterate through all registered nodes (implementation depends on node tracking)
\newcommand{\autoGroupSubnets}{
    % Placeholder for auto-grouping logic
    % Would require maintaining a list of all nodes
    % Then iterate and extract subnets
}

% Draw subnet boundaries for all auto-grouped subnets
% Usage: \renderSubnetGroups
\newcommand{\renderSubnetGroups}{
    % Iterate through detected subnets and draw boundaries
    % Implementation requires pgfkeys iteration
}

% Assign color to subnet based on trust level
% Usage: \getSubnetColor{subnet_id}
% Returns: sets \subnetcolor
\newcommand{\getSubnetColor}[1]{
    % Check if private network (high trust)
    \StrBefore{#1}{.}[\firstoctet]

    \ifthenelse{\equal{\firstoctet}{10}}{
        \def\subnetcolor{clientGreen}
        \def\trustlevel{HIGH}
    }{
    \ifthenelse{\equal{\firstoctet}{192}}{
        \def\subnetcolor{serverBlue}
        \def\trustlevel{MEDIUM}
    }{
    \ifthenelse{\equal{\firstoctet}{172}}{
        \def\subnetcolor{azureBlue}
        \def\trustlevel{MEDIUM}
    }{
        % Public IP - low trust
        \def\subnetcolor{firewallRed}
        \def\trustlevel{LOW}
    }}}
}

% Draw subnet with auto-calculated trust level
% Usage: \drawAutoSubnet{subnet_cidr}{nodes}
\newcommand{\drawAutoSubnet}[2]{
    \extractSubnet24{#1}
    \getSubnetColor{\subnetid}

    \begin{scope}[on background layer]
        \node[
            fit=#2,
            draw=\subnetcolor!60,
            fill=\subnetcolor!5,
            rounded corners=5pt,
            line width=1.5pt,
            inner sep=15pt,
            label={[fill=white, draw=\subnetcolor!60, rounded corners=2pt,
                   font=\small\bfseries\sffamily]above:#1/24 (\trustlevel)}
        ] (subnet-\subnetid) {};
    \end{scope}
}

% DMZ (Demilitarized Zone) specific styling
% Usage: \drawDMZ{name}{nodes}{label}
\newcommand{\drawDMZ}[3]{
    \begin{scope}[on background layer]
        \node[
            fit=#2,
            draw=routerOrange!70,
            fill=routerOrange!8,
            rounded corners=8pt,
            line width=2.5pt,
            inner sep=20pt,
            pattern=north east lines,
            pattern color=routerOrange!15,
            label={[fill=white, draw=routerOrange!70, rounded corners=2pt,
                   font=\small\bfseries\sffamily, text=routerOrange!90]above:#3 (DMZ)}
        ] (dmz-#1) {};
    \end{scope}
}

% VLAN boundary with distinct pattern
% Usage: \drawVLAN{vlan_id}{nodes}{color}
\newcommand{\drawVLAN}[3]{
    \begin{scope}[on background layer]
        \node[
            fit=#2,
            draw=#3!60,
            fill=#3!3,
            rounded corners=6pt,
            line width=1.5pt,
            inner sep=12pt,
            dashed,
            dash pattern=on 5pt off 3pt,
            label={[fill=white, draw=#3!60, rounded corners=2pt,
                   font=\tiny\bfseries\ttfamily]north west:VLAN #1}
        ] (vlan-#1) {};
    \end{scope}
}

% Trust boundary indicator
% Usage: \drawTrustBoundary{start_coord}{end_coord}
\newcommand{\drawTrustBoundary}[2]{
    \draw[draw=firewallRed, line width=3pt,
          double distance=2pt,
          dash pattern=on 8pt off 4pt]
        (#1) -- (#2);
    \node[font=\tiny\bfseries, text=white, fill=firewallRed,
          rounded corners=2pt, inner sep=2pt]
        at ($(#1)!0.5!(#2)$) {TRUST BOUNDARY};
}

% Geographic region grouping
% Usage: \drawRegion{name}{nodes}{region_label}{color}
\newcommand{\drawRegion}[4]{
    \begin{scope}[on background layer]
        \node[
            fit=#2,
            draw=#4!50,
            fill=#4!2,
            rounded corners=10pt,
            line width=2pt,
            inner sep=25pt,
            opacity=0.7,
            label={[fill=white, draw=#4!50, rounded corners=3pt,
                   font=\large\bfseries\sffamily]north:#3}
        ] (region-#1) {};
    \end{scope}
}

% ============================================================================
% AUTO-LAYOUT ALGORITHMS
% ============================================================================

% Tiered/Layered layout (e.g., for web architecture)
% Usage: \layoutTiered{layers}{nodes_per_layer}
\newcommand{\layoutTiered}[2]{
    % Layer 1: External (Internet, Attackers)
    % Layer 2: Perimeter (Firewalls, DMZ)
    % Layer 3: Application (Web servers, App servers)
    % Layer 4: Data (Database servers)
    % This is a placeholder - actual implementation in network_data.tex
}

% Tiered layout with automatic positioning (horizontal orientation)
% Usage: \layoutTieredHorizontal{tier_count}{base_x}{base_y}{tier_spacing}{node_spacing}
\newcommand{\layoutTieredHorizontal}[5]{
    % Store layout parameters
    \def\tiertotalcount{#1}
    \def\tierbasex{#2}
    \def\tierbasey{#3}
    \def\tierspacing{#4}
    \def\tiernodespacing{#5}
}

% Position node in tier (horizontal)
% Usage: \placeInTierH{node_id}{tier_num}{position_in_tier}{total_in_tier}{content}
\newcommand{\placeInTierH}[5]{
    % Calculate x position (tier number * tier spacing)
    \pgfmathsetmacro{\tierx}{\tierbasex + (#2 * \tierspacing)}

    % Calculate y position (centered, distributed evenly)
    % Center offset: -(total-1)/2 * spacing
    % Position offset: position * spacing
    \pgfmathsetmacro{\tiery}{\tierbasey + ((#3 - (#4-1)/2) * \tiernodespacing)}

    % Store position for this node
    \coordinate (#1-pos) at (\tierx, \tiery);
}

% Tiered layout with automatic positioning (vertical orientation)
% Usage: \layoutTieredVertical{tier_count}{base_x}{base_y}{tier_spacing}{node_spacing}
\newcommand{\layoutTieredVertical}[5]{
    % Store layout parameters
    \def\vtiertotalcount{#1}
    \def\vtierbasex{#2}
    \def\vtierbasey{#3}
    \def\vtierspacing{#4}
    \def\vtiernodespacing{#5}
}

% Position node in tier (vertical)
% Usage: \placeInTierV{node_id}{tier_num}{position_in_tier}{total_in_tier}{content}
\newcommand{\placeInTierV}[5]{
    % Calculate y position (tier number * tier spacing, going down)
    \pgfmathsetmacro{\vtiery}{\vtierbasey - (#2 * \vtierspacing)}

    % Calculate x position (centered, distributed evenly)
    \pgfmathsetmacro{\vtierx}{\vtierbasex + ((#3 - (#4-1)/2) * \vtiernodespacing)}

    % Store position for this node
    \coordinate (#1-pos) at (\vtierx, \vtiery);
}

% Calculate optimal tier spacing based on node count
% Usage: \calculateTierSpacing{max_nodes_in_tier}{min_spacing}{max_spacing}
\newcommand{\calculateTierSpacing}[3]{
    % More nodes = tighter spacing (within limits)
    \pgfmathsetmacro{\calculatedspacing}{max(#2, min(#3, #3 - (#1 * 0.3)))}
}

% N-tier architecture quick setup
% Usage: \setupNTierLayout{orientation}{tier_count}
% Orientation: horizontal or vertical
\newcommand{\setupNTierLayout}[2]{
    \ifthenelse{\equal{#1}{horizontal}}{
        \layoutTieredHorizontal{#2}{0}{0}{5}{3.5}
    }{
        \layoutTieredVertical{#2}{0}{0}{5}{3.5}
    }
}

% Circular layout (for hub-and-spoke networks)
% Usage: \layoutCircular{center_node}{satellite_nodes}{radius}
\newcommand{\layoutCircular}[3]{
    % Center node at origin
    % Satellite nodes arranged in circle
    % This is a placeholder - actual implementation in network_data.tex
}

% Circular layout with automatic angle calculation
% Usage: \layoutCircularAuto{center_x}{center_y}{radius}{node_count}{start_angle}
\newcommand{\layoutCircularAuto}[5]{
    \def\circenterx{#1}
    \def\circentery{#2}
    \def\cirradius{#3}
    \def\cirnodecount{#4}
    \def\cirstartangle{#5}
    \pgfmathsetmacro{\ciranglestep}{360/#4}
}

% Place node in circular layout
% Usage: \placeInCircle{node_id}{position_index}
\newcommand{\placeInCircle}[2]{
    % Calculate angle for this position
    \pgfmathsetmacro{\nodeangle}{\cirstartangle + (#2 * \ciranglestep)}

    % Calculate x,y coordinates
    \pgfmathsetmacro{\nodex}{\circenterx + \cirradius * cos(\nodeangle)}
    \pgfmathsetmacro{\nodey}{\circentery + \cirradius * sin(\nodeangle)}

    % Store position
    \coordinate (#1-pos) at (\nodex, \nodey);
}

% Multi-ring circular layout (concentric circles)
% Usage: \layoutMultiRing{center_x}{center_y}{ring_count}{base_radius}{radius_increment}
\newcommand{\layoutMultiRing}[5]{
    \def\ringcenterx{#1}
    \def\ringcentery{#2}
    \def\ringcount{#3}
    \def\ringbaseradius{#4}
    \def\ringinc{#5}
}

% Place node in multi-ring layout
% Usage: \placeInRing{node_id}{ring_number}{position_in_ring}{total_in_ring}
\newcommand{\placeInRing}[4]{
    % Calculate radius for this ring
    \pgfmathsetmacro{\thisradius}{\ringbaseradius + (#2 * \ringinc)}

    % Calculate angle
    \pgfmathsetmacro{\thisangle}{#3 * (360/#4)}

    % Calculate position
    \pgfmathsetmacro{\thisx}{\ringcenterx + \thisradius * cos(\thisangle)}
    \pgfmathsetmacro{\thisy}{\ringcentery + \thisradius * sin(\thisangle)}

    % Store position
    \coordinate (#1-pos) at (\thisx, \thisy);
}

% Calculate optimal radius based on node count
% Usage: \calculateCircularRadius{node_count}{min_node_spacing}
\newcommand{\calculateCircularRadius}[2]{
    % Circumference = node_count * min_spacing
    % Radius = Circumference / (2 * pi)
    \pgfmathsetmacro{\optimalradius}{(#1 * #2) / (2 * 3.14159)}
}

% Arc layout (partial circle)
% Usage: \layoutArc{center_x}{center_y}{radius}{node_count}{start_angle}{end_angle}
\newcommand{\layoutArc}[6]{
    \def\arccenterx{#1}
    \def\arccentery{#2}
    \def\arcradius{#3}
    \def\arcnodecount{#4}
    \def\arcstartangle{#5}
    \def\arcendangle{#6}
    \pgfmathsetmacro{\arcrange}{#6 - #5}
    \pgfmathsetmacro{\arcanglestep}{\arcrange / (#4 - 1)}
}

% Place node in arc layout
% Usage: \placeInArc{node_id}{position_index}
\newcommand{\placeInArc}[2]{
    % Calculate angle for this position
    \pgfmathsetmacro{\arcnodeangle}{\arcstartangle + (#2 * \arcanglestep)}

    % Calculate position
    \pgfmathsetmacro{\arcnodex}{\arccenterx + \arcradius * cos(\arcnodeangle)}
    \pgfmathsetmacro{\arcnodey}{\arccentery + \arcradius * sin(\arcnodeangle)}

    % Store position
    \coordinate (#1-pos) at (\arcnodex, \arcnodey);
}

% Grid layout (for data centers)
% Usage: \layoutGrid{rows}{cols}{spacing}
\newcommand{\layoutGrid}[3]{
    % Regular grid arrangement
    % This is a placeholder - actual implementation in network_data.tex
}

% Grid layout with automatic positioning
% Usage: \layoutGridAuto{base_x}{base_y}{rows}{cols}{row_spacing}{col_spacing}
\newcommand{\layoutGridAuto}[6]{
    \def\gridbasex{#1}
    \def\gridbasey{#2}
    \def\gridrows{#3}
    \def\gridcols{#4}
    \def\gridrowspacing{#5}
    \def\gridcolspacing{#6}
}

% Place node in grid
% Usage: \placeInGrid{node_id}{row}{col}
\newcommand{\placeInGrid}[3]{
    % Calculate position
    \pgfmathsetmacro{\gridx}{\gridbasex + (#3 * \gridcolspacing)}
    \pgfmathsetmacro{\gridy}{\gridbasey - (#2 * \gridrowspacing)}

    % Store position
    \coordinate (#1-pos) at (\gridx, \gridy);
}

% Calculate optimal grid dimensions for node count
% Usage: \calculateGridDimensions{node_count}
% Result: sets \gridbestrows and \gridbestcols
\newcommand{\calculateGridDimensions}[1]{
    % Try to make grid as square as possible
    \pgfmathsetmacro{\gridsqrt}{sqrt(#1)}
    \pgfmathsetmacro{\gridbestcols}{ceil(\gridsqrt)}
    \pgfmathsetmacro{\gridbestrows}{ceil(#1/\gridbestcols)}
}

% Irregular grid (varying column counts per row)
% Usage: \layoutIrregularGrid{base_x}{base_y}{row_spacing}{col_spacing}
\newcommand{\layoutIrregularGrid}[4]{
    \def\irregridbasex{#1}
    \def\irregridbasey{#2}
    \def\irregridrowspacing{#3}
    \def\irregridcolspacing{#4}
}

% Place node in irregular grid
% Usage: \placeInIrregularGrid{node_id}{row}{col}{total_in_row}
\newcommand{\placeInIrregularGrid}[4]{
    % Center the row
    \pgfmathsetmacro{\rowoffset}{-(#4-1)/2 * \irregridcolspacing}
    \pgfmathsetmacro{\irregridx}{\irregridbasex + \rowoffset + (#3 * \irregridcolspacing)}
    \pgfmathsetmacro{\irregridy}{\irregridbasey - (#2 * \irregridrowspacing)}

    % Store position
    \coordinate (#1-pos) at (\irregridx, \irregridy);
}

% Server rack layout (vertical stacking)
% Usage: \layoutServerRack{base_x}{base_y}{rack_units}{unit_height}
\newcommand{\layoutServerRack}[4]{
    \def\rackbasex{#1}
    \def\rackbasey{#2}
    \def\rackunits{#3}
    \def\rackunitheight{#4}
}

% Place server in rack
% Usage: \placeInRack{node_id}{rack_unit}
\newcommand{\placeInRack}[2]{
    % Calculate y position (rack units count from bottom up)
    \pgfmathsetmacro{\racky}{\rackbasey + (#2 * \rackunitheight)}

    % Store position
    \coordinate (#1-pos) at (\rackbasex, \racky);
}

% ============================================================================
% BACKGROUND ELEMENTS
% ============================================================================

% Draw optional background grid
\newcommand{\drawBackgroundGrid}{
    % Optional grid for reference - can be toggled
    % \draw[step=1cm, gray!20, very thin] (-10,-10) grid (10,10);
}

% Configurable background grid
% Usage: \drawConfigurableGrid{step_size}{color}{line_width}{min_x}{min_y}{max_x}{max_y}
\newcommand{\drawConfigurableGrid}[7]{
    \begin{scope}[on background layer]
        \draw[step=#1, #2, line width=#3] (#4,#5) grid (#6,#7);
    \end{scope}
}

% Major/minor grid (like graph paper)
% Usage: \drawGraphPaperGrid{major_step}{minor_step}{bounds}
\newcommand{\drawGraphPaperGrid}[3]{
    \begin{scope}[on background layer]
        % Minor grid
        \draw[step=#2, gray!10, very thin] #3 grid #3;
        % Major grid
        \draw[step=#1, gray!30, thin] #3 grid #3;
    \end{scope}
}

% Polar grid background (for circular layouts)
% Usage: \drawPolarGrid{center_x}{center_y}{max_radius}{radial_steps}{angular_steps}
\newcommand{\drawPolarGrid}[5]{
    \begin{scope}[on background layer]
        % Radial circles
        \foreach \r in {1,...,#4} {
            \pgfmathsetmacro{\radius}{#3 * \r / #4}
            \draw[gray!20, thin] (#1,#2) circle (\radius);
        }
        % Angular lines
        \foreach \a in {0,...,#5} {
            \pgfmathsetmacro{\angle}{360 * \a / #5}
            \draw[gray!20, thin] (#1,#2) -- ++(\angle:#3);
        }
    \end{scope}
}

% Hexagonal grid (for honeycomb layouts)
% Usage: \drawHexGrid{origin_x}{origin_y}{hex_size}{rows}{cols}
\newcommand{\drawHexGrid}[5]{
    \begin{scope}[on background layer]
        % Simplified hexagonal grid pattern
        % Full implementation would require more complex geometry
        \draw[gray!15, thin] (#1,#2) grid[step=#3] ++(#3*#5, #3*#4);
    \end{scope}
}

% ============================================================================
% HIERARCHICAL LAYOUTS
% ============================================================================

% Tree layout for hierarchical networks
% Usage: \layoutTree{root}{levels}{branching_factor}
\newcommand{\layoutTree}[3]{
    % Root at top
    % Children arranged in levels below
    % This is a placeholder - actual implementation needed
}

% Tree layout with automatic positioning
% Usage: \layoutTreeAuto{root_x}{root_y}{levels}{level_spacing}{node_spacing}
\newcommand{\layoutTreeAuto}[5]{
    \def\treerootx{#1}
    \def\treerooty{#2}
    \def\treelevels{#3}
    \def\treelevelspacing{#4}
    \def\treenodespacing{#5}
}

% Place node in tree layout
% Usage: \placeInTree{node_id}{level}{position_in_level}{total_in_level}
\newcommand{\placeInTree}[4]{
    % Calculate y position (levels go down from root)
    \pgfmathsetmacro{\treey}{\treerooty - (#2 * \treelevelspacing)}

    % Calculate x position (centered around root)
    \pgfmathsetmacro{\treex}{\treerootx + ((#3 - (#4-1)/2) * \treenodespacing)}

    % Store position
    \coordinate (#1-pos) at (\treex, \treey);
}

% Binary tree layout helper
% Usage: \layoutBinaryTree{root_x}{root_y}{depth}{h_spacing}{v_spacing}
\newcommand{\layoutBinaryTree}[5]{
    \def\btreerootx{#1}
    \def\btreerooty{#2}
    \def\btreedepth{#3}
    \def\btreehspacing{#4}
    \def\btreevspacing{#5}
}

% Place node in binary tree (using path notation)
% Usage: \placeInBinaryTree{node_id}{depth}{path}
% Path: 0=left, 1=right (e.g., "01" means left then right)
\newcommand{\placeInBinaryTree}[3]{
    % Start at root
    \pgfmathsetmacro{\btreex}{\btreerootx}
    \pgfmathsetmacro{\btreey}{\btreerooty}

    % Calculate position based on path
    % Each level halves the horizontal spacing
    \pgfmathsetmacro{\currentspacing}{\btreehspacing}

    % Move down by depth
    \pgfmathsetmacro{\btreey}{\btreerooty - (#2 * \btreevspacing)}

    % This is simplified - full implementation would parse path string
    % For now, store position
    \coordinate (#1-pos) at (\btreex, \btreey);
}

% Inverted tree layout (root at bottom)
% Usage: \layoutInvertedTree{root_x}{root_y}{levels}{level_spacing}{node_spacing}
\newcommand{\layoutInvertedTree}[5]{
    \def\invtreerootx{#1}
    \def\invtreerooty{#2}
    \def\invtreelevels{#3}
    \def\invtreelevelspacing{#4}
    \def\invtreenodespacing{#5}
}

% Place node in inverted tree
% Usage: \placeInInvertedTree{node_id}{level}{position_in_level}{total_in_level}
\newcommand{\placeInInvertedTree}[4]{
    % Calculate y position (levels go up from root)
    \pgfmathsetmacro{\invtreey}{\invtreerooty + (#2 * \invtreelevelspacing)}

    % Calculate x position (centered)
    \pgfmathsetmacro{\invtreex}{\invtreerootx + ((#3 - (#4-1)/2) * \invtreenodespacing)}

    % Store position
    \coordinate (#1-pos) at (\invtreex, \invtreey);
}

% Calculate optimal tree node spacing based on branching factor
% Usage: \calculateTreeSpacing{branching_factor}{depth}{min_spacing}
\newcommand{\calculateTreeSpacing}[3]{
    % Bottom level needs space for all leaf nodes
    % Spacing = branching_factor^depth * min_spacing
    \pgfmathsetmacro{\leafcount}{#1^#2}
    \pgfmathsetmacro{\treecalcspacing}{\leafcount * #3}
}

% ============================================================================
% ORGANIC/FORCE-DIRECTED LAYOUTS
% ============================================================================

% Force-directed layout (physics-based)
% This requires external computation or pre-calculated positions
\newcommand{\layoutForceDirected}{
    % Placeholder for force-directed positioning
    % Would ideally use external tool (GraphViz, networkx) for calculation
}

% TODO: Force-directed layout integration
% - Integration with external graph layout tools
% - Spring-embedder algorithm implementation
% - Fruchterman-Reingold algorithm
% - Kamada-Kawai algorithm
% - Export/import position data format

% ============================================================================
% SUBNET AUTO-GROUPING
% ============================================================================

% Automatically group nodes by IP subnet
% Usage: \autoGroupSubnets
\newcommand{\autoGroupSubnets}{
    % Analyze IP addresses and create subnet boundaries
    % This requires parsing logic
}

% TODO: Intelligent subnet grouping
% - Parse IP addresses to determine subnets
% - Automatically create subnet boundaries
% - Color-code subnets by trust level
% - Handle overlapping/nested subnets
% - Support for CIDR notation

% ============================================================================
% LAYOUT HELPERS AND UTILITIES
% ============================================================================

% Calculate midpoint between two nodes
% Usage: \nodeMidpoint{node1}{node2}{resultname}
\newcommand{\nodeMidpoint}[3]{
    \coordinate (#3) at ($(#1)!0.5!(#2)$);
}

% Position node relative to another
% Usage: \positionRelative{newnode}{refnode}{distance}{angle}{style}
\newcommand{\positionRelative}[5]{
    \node[#5] (#1) at ($(#2)+({#4}:{#3})$) {};
}

% ============================================================================
% COLLISION DETECTION AND AVOIDANCE
% ============================================================================

% Store node bounding box for collision detection
% Usage: \registerNodeBounds{node_id}{width}{height}
\newcommand{\registerNodeBounds}[3]{
    \pgfkeys{/nodebounds/#1/width/.initial=#2}
    \pgfkeys{/nodebounds/#1/height/.initial=#3}
}

% Check if two nodes would overlap
% Usage: \checkNodeOverlap{node1_id}{x1}{y1}{node2_id}{x2}{y2}
% Returns: sets \nodesoverlap to 1 if overlap, 0 if no overlap
\newcommand{\checkNodeOverlap}[6]{
    % Get bounding box dimensions
    \pgfkeysgetvalue{/nodebounds/#1/width}{\nodeonewidth}
    \pgfkeysgetvalue{/nodebounds/#1/height}{\nodeoneheight}
    \pgfkeysgetvalue{/nodebounds/#4/width}{\nodetwowidth}
    \pgfkeysgetvalue{/nodebounds/#4/height}{\nodetwoheight}

    % Calculate half-widths and half-heights
    \pgfmathsetmacro{\halfwidthone}{\nodeonewidth/2}
    \pgfmathsetmacro{\halfheightone}{\nodeoneheight/2}
    \pgfmathsetmacro{\halfwidthtwo}{\nodetwowidth/2}
    \pgfmathsetmacro{\halfheighttwo}{\nodetwoheight/2}

    % Calculate distance between centers
    \pgfmathsetmacro{\deltax}{abs(#2 - #5)}
    \pgfmathsetmacro{\deltay}{abs(#3 - #6)}

    % Check overlap in both dimensions
    \pgfmathsetmacro{\minxdist}{\halfwidthone + \halfwidthtwo}
    \pgfmathsetmacro{\minydist}{\halfheightone + \halfheighttwo}

    \pgfmathsetmacro{\nodesoverlap}{(\deltax < \minxdist && \deltay < \minydist) ? 1 : 0}
}

% Calculate minimum safe distance between two nodes
% Usage: \calculateSafeDistance{node1_width}{node1_height}{node2_width}{node2_height}{padding}
\newcommand{\calculateSafeDistance}[5]{
    % Diagonal distance to ensure no overlap
    \pgfmathsetmacro{\safedist}{sqrt((#1/2 + #3/2 + #5)^2 + (#2/2 + #4/2 + #5)^2)}
}

% Adjust position to avoid collision
% Usage: \avoidCollision{node_id}{current_x}{current_y}{obstacle_x}{obstacle_y}
% Returns: sets \adjustedx and \adjustedy
\newcommand{\avoidCollision}[5]{
    % Calculate vector away from obstacle
    \pgfmathsetmacro{\avoidvecx}{#2 - #4}
    \pgfmathsetmacro{\avoidvecy}{#3 - #5}

    % Normalize and scale
    \pgfmathsetmacro{\avoidveclen}{sqrt(\avoidvecx^2 + \avoidvecy^2)}
    \pgfmathsetmacro{\pushstrength}{2.0}

    % Calculate adjusted position
    \pgfmathsetmacro{\adjustedx}{#2 + (\avoidvecx/\avoidveclen) * \pushstrength}
    \pgfmathsetmacro{\adjustedy}{#3 + (\avoidvecy/\avoidveclen) * \pushstrength}
}

% Snap coordinate to grid
% Usage: \snapToGrid{x}{y}{grid_size}
% Returns: sets \snappedx and \snappedy
\newcommand{\snapToGrid}[3]{
    \pgfmathsetmacro{\snappedx}{round(#1/#3) * #3}
    \pgfmathsetmacro{\snappedy}{round(#2/#3) * #3}
}

% Magnetic alignment - snap to nearby node alignment
% Usage: \magneticAlign{x}{y}{reference_node_x}{reference_node_y}{threshold}
% Returns: sets \alignedx and \alignedy
\newcommand{\magneticAlign}[5]{
    % Check if close enough to snap
    \pgfmathsetmacro{\deltaxalign}{abs(#1 - #3)}
    \pgfmathsetmacro{\deltayalign}{abs(#2 - #4)}

    % Snap if within threshold
    \pgfmathsetmacro{\alignedx}{(\deltaxalign < #5) ? #3 : #1}
    \pgfmathsetmacro{\alignedy}{(\deltayalign < #5) ? #4 : #2}
}

% Distribute nodes evenly along a line
% Usage: \distributeAlongLine{count}{start_x}{start_y}{end_x}{end_y}
\newcommand{\distributeAlongLine}[5]{
    \def\distcount{#1}
    \def\diststartx{#2}
    \def\diststarty{#3}
    \def\distendx{#4}
    \def\distendy{#5}
    \pgfmathsetmacro{\diststepx}{(#4 - #2)/(#1 - 1)}
    \pgfmathsetmacro{\diststepy}{(#5 - #3)/(#1 - 1)}
}

% Get position in distributed line
% Usage: \getDistributedPosition{index}
% Returns: sets \distx and \disty
\newcommand{\getDistributedPosition}[1]{
    \pgfmathsetmacro{\distx}{\diststartx + (#1 * \diststepx)}
    \pgfmathsetmacro{\disty}{\diststarty + (#1 * \diststepy)}
}

% Distribute nodes evenly in rectangular area
% Usage: \distributeInArea{count}{min_x}{min_y}{max_x}{max_y}
\newcommand{\distributeInArea}[5]{
    % Calculate grid for distribution
    \pgfmathsetmacro{\areasqrt}{sqrt(#1)}
    \pgfmathsetmacro{\areacols}{ceil(\areasqrt)}
    \pgfmathsetmacro{\arearows}{ceil(#1/\areacols)}

    \def\areaminx{#2}
    \def\areaminy{#3}
    \def\areamaxx{#4}
    \def\areamaxy{#5}
    \pgfmathsetmacro{\areaspacingx}{(#4 - #2)/(\areacols + 1)}
    \pgfmathsetmacro{\areaspacingy}{(#5 - #3)/(\arearows + 1)}
}

% Get position in distributed area
% Usage: \getAreaPosition{index}
% Returns: sets \areax and \areay
\newcommand{\getAreaPosition}[1]{
    \pgfmathsetmacro{\arearow}{floor(#1/\areacols)}
    \pgfmathsetmacro{\areacol}{mod(#1, \areacols)}

    \pgfmathsetmacro{\areax}{\areaminx + (\areacol + 1) * \areaspacingx}
    \pgfmathsetmacro{\areay}{\areaminy + (\arearow + 1) * \areaspacingy}
}

% ============================================================================
% MULTI-PAGE LAYOUT SUPPORT
% ============================================================================

% For very large networks, split across pages
\newcommand{\layoutMultiPage}[1]{
    % Page 1: Overview with all major components
    % Page 2+: Detailed views of each subnet
}

% TODO: Multi-page diagram support
% - Automatic page breaking for large networks
% - Cross-reference markers between pages
% - Consistent positioning across pages
% - Overview + detail pages
% - Thumbnail navigation map

% ============================================================================
% DYNAMIC LAYOUT ADJUSTMENT
% ============================================================================

% Adjust layout based on diagram density
\newcommand{\optimizeLayout}{
    % Analyze node density
    % Adjust spacing and scale accordingly
}

% Calculate diagram complexity score
% Usage: \calculateComplexity{node_count}{connection_count}
% Returns: sets \complexityscore (0-100)
\newcommand{\calculateComplexity}[2]{
    % Simple heuristic: nodes + connections/2
    \pgfmathsetmacro{\complexityscore}{min(100, #1 + #2/2)}
}

% Auto-adjust spacing based on complexity
% Usage: \autoAdjustSpacing{complexity_score}{base_spacing}
% Returns: sets \adjustedspacing
\newcommand{\autoAdjustSpacing}[2]{
    % Higher complexity = tighter spacing (to a limit)
    \pgfmathsetmacro{\spacingfactor}{max(0.5, 1.5 - #1/100)}
    \pgfmathsetmacro{\adjustedspacing}{#2 * \spacingfactor}
}

% Calculate optimal diagram bounds
% Usage: \calculateDiagramBounds{node_count}{layout_type}
% Returns: sets \diagramwidth and \diagramheight
\newcommand{\calculateDiagramBounds}[2]{
    \ifthenelse{\equal{#2}{grid}}{
        % Square-ish layout
        \pgfmathsetmacro{\sidelength}{ceil(sqrt(#1)) * 4}
        \pgfmathsetmacro{\diagramwidth}{\sidelength}
        \pgfmathsetmacro{\diagramheight}{\sidelength}
    }{
    \ifthenelse{\equal{#2}{tiered}}{
        % Wide layout
        \pgfmathsetmacro{\diagramwidth}{20}
        \pgfmathsetmacro{\diagramheight}{#1 * 0.5}
    }{
        % Default
        \pgfmathsetmacro{\diagramwidth}{15}
        \pgfmathsetmacro{\diagramheight}{15}
    }}
}

% Scale diagram to fit page
% Usage: \scaleDiagramToPage{page_width}{page_height}{diagram_width}{diagram_height}
% Returns: sets \pagescale
\newcommand{\scaleDiagramToPage}[4]{
    \pgfmathsetmacro{\scalex}{#1/#3}
    \pgfmathsetmacro{\scaley}{#2/#4}
    \pgfmathsetmacro{\pagescale}{min(\scalex, \scaley) * 0.9}
}

% Optimize for print (higher DPI, better spacing)
\newcommand{\optimizeForPrint}{
    \pgfkeys{/tikz/.cd,
        line width=1.2pt,
        font=\normalsize
    }
}

% Optimize for screen (lighter, clearer)
\newcommand{\optimizeForScreen}{
    \pgfkeys{/tikz/.cd,
        line width=1pt,
        font=\small
    }
}

% Compact layout mode (reduce all spacing by factor)
% Usage: \enableCompactMode{compression_factor}
\newcommand{\enableCompactMode}[1]{
    \pgfmathsetmacro{\compactfactor}{#1}
    \setlength{\nodeSpacing}{\compactfactor\nodeSpacing}
    \setlength{\layerSpacing}{\compactfactor\layerSpacing}
    \setlength{\subnetSpacing}{\compactfactor\subnetSpacing}
}

% Expanded layout mode (increase all spacing)
% Usage: \enableExpandedMode{expansion_factor}
\newcommand{\enableExpandedMode}[1]{
    \pgfmathsetmacro{\expandfactor}{#1}
    \setlength{\nodeSpacing}{\expandfactor\nodeSpacing}
    \setlength{\layerSpacing}{\expandfactor\layerSpacing}
    \setlength{\subnetSpacing}{\expandfactor\subnetSpacing}
}
